<!doctype html>
<html>

<head>
	<title>PHP Best Practices: 일반적이고 복잡한 PHP 작업을 위한 짧고 실용적인 가이드</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link type="text/css" rel="stylesheet" href="css/core.css" media="screen" />
	<link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCore.css" media="screen" />
	<link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCoreDefault.css" media="screen" />
	<script type="text/javascript" src="js/jquery/jquery-1.7.2.min.js"></script>
	<script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shCore.js"></script>
	<script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shBrushPhp.js"></script>
	<script type="text/javascript">
	$(document).ready(function() {
		$('code.php').attr('class', 'php brush: php');
		SyntaxHighlighter.config.tagName = 'code';
		SyntaxHighlighter.all()
	});
	</script>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-62991110-1', 'auto');
	  ga('send', 'pageview');
	</script>
</head>

<body>
	<header>
		<h1>PHP Best Practices</h1>
		<h2>일반적이고 복잡한 PHP 작업을 위한 짧고 실용적인 가이드</h2>
	</header>
	<main>
		<nav>
			<ol>
				<li><a href="#maintainers">최신 개정판 &amp; 관리자</a></li>
				<li><a href="#introduction">소개</a></li>
				<li><a href="#version">어떤 PHP 버전을 사용하나요?</a></li>
				<li><a href="#passwords">비밀번호 저장하기</a></li>
				<li><a href="#mysql">PHP와 MySQL</a></li>
				<li><a href="#php-tags">PHP 태그</a></li>
				<li><a href="#auto-loading">클래스 오토로딩(Auto-loading)</a></li>
				<li><a href="#quotes">작은 따옴표와 큰 따옴표</a></li>
				<li><a href="#constants">define() 과 const</a></li>
				<li><a href="#opcode-cache">PHP opcode 캐시</a></li>
				<li><a href="#memcached">PHP와 Memcached</a></li>
				<li><a href="#regex">PHP와 정규표현식</a></li>
				<li><a href="#serving-php">서버에 PHP 올리기</a></li>
				<li><a href="#email">이메일 보내기</a></li>
				<li><a href="#validating-emails">이메일 주소 검사하기</a></li>
				<li><a href="#sanitizing-html">Sanitizing HTML</a></li>
				<li><a href="#utf-8">PHP와 UTF-8</a></li>
				<li><a href="#working-with-dates-and-times">날짜와 시간을 다루기</a></li>
				<li><a href="#checking-for-null">null과 false 값 확인하기</a></li>
				<li><a href="#suggestions">제안이나 수정사항</a></li>
			</ol>
		</nav>
		<article>
			<h2>PHP Best Practices</h2>
			<section id="maintainers">
				<h2>최신 개정판 &amp; 관리자</h2>
				<p>이 문서는 2014년 7월 3일에 최종 확인했습니다. 2014년 7월 3일에 최종 수정되었습니다.</p>
				<p>이 문서는 저, <a href="https://alexcabal.com" rel="author">Alex Cabal</a>이 관리하고 있습니다. 저는 오랜 기간 PHP를 작성해왔고, 현재 <a href="http://www.scribophile.com/">진지한 작가를 위한 온라인 글쓰기 그룹인 Scribophile</a>, <a href="http://writerfolio.com">프리랜서를 위한 쉬운 온라인 글쓰기 포트폴리오인 Writerfolio</a>, <a href="https://standardebooks.com">삽화가 들어간 DRM없는 퍼블릭 도메인 eBook을 출판하는 Standard Ebooks</a> 등을 운영하고 있습니다. 가끔 흥미를 갖게하는 프로젝트나 의뢰인들을 위해서 프리랜서로 일합니다.</p>
				<p>제가 뭔가 도울일이 있거나 이 문서에 어떤 제안이나 정정할 것이 있다면 <a href="https://alexcabal.com/contact/">연락주세요.</a></p>
				<h3>한국어판 안내</h3>
				<p>이 문서는 2015년 5월 11일에 최종 번역되었습니다. 한국어판에 대한 제안/문의는 <a href="https://github.com/meye/php-best-practices/issues">Github 저장소</a>에 이슈로 남겨주세요.</p>

				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="introduction">
				<h2>소개</h2>
				<p>PHP는 수년간 비틀리고, 휘어지고, 늘려지고, 난도질 당해온 복잡한 언어입니다. PHP는 매우 일관성이 없고 가끔 결함도 있습니다. 각 버전마다 각각의 독특한 기능과 결점, 특성을 가지고 있어서, 어떤 버전에 어떤 문제가 있는지 계속 확인해나가는 것은 쉽지 않습니다. 종종 그렇듯이 왜 PHP가 그렇게 미움을 받는지 아는 것은 간단합니다.</p>
				<p>그럼에도 불구하고, PHP는 오늘날 웹에서 가장 인기있는 언어입니다. PHP의 긴 역사로 인해서 비밀번호 해싱(hashing)이나 데이터베이스 사용과 같은 기본적인 것을 어떻게 하는지에 관한 많은 학습서(tutorials)를 찾을 수 있습니다. 문제는 5개의 문서를 본다면 무언가를 하기위한 완전히 다른 다섯가지 방법을 발견하게 될 가능성이 높다는 것입니다. 어떤 방법이 "옳은" 방법일까요? 다른 방법들은 잠재적인 버그나 문제(gotchas)가 있는 건가요? 이런 것을 알아내기는 정말 어렵습니다. 여러분은 정답을 알아내기 위해서 인터넷을 찾아볼겁니다.</p>
				<p>이것은 새로운 PHP 프로그래머들이 보기 흉하고, 구식이며, 안전하지 않은 코드때문에 매우 자주 비난당하는 한가지 이유가 됩니다. 하지만 첫번째 구글 검색 결과가 5년된 방법을 가르치는 4년된 문서라면 그들도 어쩔 수 없습니다.</p>
				<p>이 문서는 이런 문제를 해결하고자 합니다. PHP에서 일반적이고 복잡한 문제와 작업을 위한 모범 사례(best practices)로 꼽을 수 있는 기본적인 설명들을 한데 모아보고자 합니다. 저 수준의 작업이 PHP에서 다양하고 복잡한 해결방법들이 있다면, 여기에 해당합니다.</p>
				<h3>이 문서가 포함하는 것</h3>
				<p>이 문서는 PHP 프로그래머가 직면할만한 일반적인 <em>저 수준</em>의 작업이지만, PHP가 많은 선택권을 제공하기 때문에 불명확한 작업을 만났을때 택해야할 가장 바람직한 방법을 제안하는 안내서입니다. 예를 들자면, 데이터베이스 연결하기는 PHP에서 많은 방법이 가능한 일반적인 작업이지만, 그것들 전부가 좋은 방법은 아닙니다. 따라서, 이것은 이 문서에 포함됩니다.</p>
				<p>이 문서는 해결 방법들을 짧게 소개하고 있습니다. 예제는 여러분을 기본적인 설정을 알려주겠지만, 여러분은 나름대로 관련 자료를 찾아서 유용한 것들로 살을 붙여야 합니다.</p>
				<p>이 문서는 최신 PHP를 사용하는 것을 가정합니다. 그래서 여러분이 오래된 버전의 PHP를 사용한다면 이러한 해결 방법들에서 사용하는 어떤 기능들을 사용하지 못할지도 모릅니다.</p>
				<p>이 문서는 살아있는 문서로 PHP가 발전하는 것에 맞춰서 이 문서도 계속 수정하도록 최선을 다할 예정입니다.</p>
				<h3>이 문서가 <em>포함하지 않는 것</em></h3>
				<p>이 문서는 PHP 학습서가 아닙니다. PHP의 기본적인 내용과 문법 등은 다른 곳에서 배우셔야 합니다.</p>
				<p>이 문서는 쿠키 저장이나 캐쉬(caching), 코딩 스타일, 문서화 등과 같은 일반적인 웹 애플리케이션 문제를 위한 안내서가 아닙니다.</p>
				<p>이 문서는 보안 안내서가 아닙니다. 보안 관련 문제를 조금 다루고 있긴 하지만, 여러분의 PHP 애플리케이션을 안전하게 만들기 위해서는 별도로 관련자료를 찾아보셔야 합니다. 특히, 여기에서 제안한 방법을 구현하기 전에 신중하게 검토하십시오. 여러분의 코드는 여러분 자신의 책임입니다.</p>
				<p>이 문서는 특정 코딩 스타일이나 패턴, 프레임워크를 주장하지 않습니다.</p>
				<p>이 문서는 사용자 등록, 로그인 시스템 등과 같은 고 수준 작업을 하기 위한 특정 방법을 옹호하지 않습니다. 이 문서는 철처히 PHP의 긴 역사로 인해서 해결 방법이 복잡하고 불명확할 수 있는 <em>저 수준</em> 작업을 위한 문서입니다.</p>
				<p>이 문서에 소개된 방법이 가장 중요하거나 <em>단 하나의</em> 방법인 것은 아닙니다. 소개된 어떤 방법들은 여러분의 상황에서는 최선이 아닐 수도 있고, 동일한 결과를 얻기위한 다른 많은 방법이 있습니다. 특히 로드가 심한(high-load) 웹 애플리케이션들은 이런 문제에 대한 더 난해한 해결 방법이 도움이 될 수도 있습니다.</p>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="version">
				<h2>어떤 PHP 버전을 사용하나요?</h2>
				<h3>Ubuntu 14.04 LTS에 설치된 PHP 5.5.9-1ubuntu4.2</h3>
				<p>PHP는 웹 세계의 100살 먹은 거북이입니다. 이 거북이의 등껍질에는 풍성하고, 복잡하며, 굴곡진 역사가 새겨져있습니다. 호스팅 환경에서는 여러분이 할 수 있는 것에 제약이 있을 수도 있습니다.</p>
				<p>온전함을 유지하기 위해서 하나의 PHP 버전에 집중할 것입니다. 2013년 4월 30일 기준으로 <strong>PHP 5.5.9-1ubuntu4.2</strong>가 그렇습니다. 이것은 <strong>Ubuntu 14.04 LTS</strong> 서버에서 apt-get을 사용할때 설치되는 버전입니다. 다시 말하면, 많은 사람들이 사용하는 온전한 초기값입니다.</p>
				<p>여기에 소개하는 어떤 해결방법은 다른 버전이나 오래된 버전의 PHP에서 잘 동작하는 것을 발견할지도 모릅니다. 그런 경우, <em>오래된 버전에 숨어있는 버그나 보안 문제들을 확인하는 것은 여러분의 몫입니다.</em></p>
				<aside>
					<h3>Ubuntu 12.04 LTS를 위한 안내</h3>
					<p>Ubuntu 12.04와 Ubuntu 14.04 사이에 PHP 세계에서는 많은 변화가 있었습니다. 12.04를 여전히 흔하게 사용하고 있고, 아래의 몇몇 방법들은 14.04에서 큰 변화가 있기때문에, 이와 같은 박스안에 12.04를 위한 방법을 소개하겠습니다.</p>
					<p>Ubuntu 12.04에서 apt-get으로 설치되는 PHP 버전은 <b>PHP 5.3.10-1ubuntu3.6 with Suhosin-Patch</b>입니다.</p>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="passwords">
				<h2>비밀번호 저장하기</h2>
				<h3>비밀번호를 해시하고 비교할때 내장(built-in) <a href="http://php.net/book.password">비밀번호 해싱</a> 함수를 사용하세요.</h3>
				<p>해싱은 데이터베이스에 저장하기 전에 사용자의 비밀번호를 보호하는 관례적인 방법입니다. md5나 심지어 sha1과 같은 많은 일반적인 해싱 알고리즘은 <a href="http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/">해커들이 쉽게 비밀번호를 알아낼 수 있기 때문에</a> 비밀번호를 저장하기에는 안전하지 않습니다.</p>
				<p>PHP는 현재 비밀번호 해싱을 위한 최고의 알고리즘으로 여기는 bcript 알고리즘을 사용하는 내장(built-in) 비밀번호 해싱 라이브러리를 제공합니다.</p>
				<h4>예제</h4>
				<code class="php">
					&lt;?php
					// 비밀번호를 해시합니다.  $hashedPassword 는 60자 문자열이 됩니다.
					$hashedPassword = password_hash('my super cool password', PASSWORD_DEFAULT);

					// 이제 $hashedPassword 내용을 안전하게 데이터베이스에 저장할 수 있습니다.

					// 사용자가 입력한 것과 해시를 비교하여 올바른 비밀번호를 입력했는지 확인합니다.
					password_verify('the wrong password', $hashedPassword); // false

					password_verify('my super cool password', $hashedPassword); // true
					?&gt;</code>
				<h4>참고</h4>
				<ul>
					<li>많은 사람들이 비밀번호를 해싱하기 전에 salt값을 추가하라고(소금을 치라고) 권장할 것입니다. 그것은 좋은 생각인데, <code>password_hash()</code>는 이미 salt값을 추가해줍니다. 여러분이 직접 salt값을 추가할 필요가 없다는 말입니다.</li>
				</ul>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://blogs.msdn.com/b/lixiong/archive/2011/12/25/md5-sha1-salt-and-bcrypt.aspx">Why hashing passwords with md5 or sha is unsafe</a></li>
					<li><a href="http://codahale.com/how-to-safely-store-a-password/">How to safely store a password</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)</h3>
					<h3>비밀번호를 해싱하고 비교할때 <a href="http://www.openwall.com/phpass/">phpass</a> 라이브러리를 사용하세요.</h3>
					<p><em><a href="http://www.openwall.com/phpass/">phpass</a> 0.3</em>에서 테스트했습니다.</p>
					<p>12.04에 설치된 PHP 버전에서는 내장 PHP 비밀번호 해싱 라이브러리를 사용할 수 없습니다. 대신, 사용이 쉽고 동일한 bcrypt 기반의 기능을 제공하는 오픈소스 <a href="http://www.openwall.com/phpass/">phpass</a> 라이브러리를 사용하세요.</p>
					<h4>예제</h4>
					<code class="php">
						&lt;?php
						// Include the phpass library
						require_once('phpass-0.3/PasswordHash.php');

						// Initialize the hasher without portable hashes (this is more secure)
						$hasher = new PasswordHash(8, false);

						// Hash the password.  $hashedPassword will be a 60-character string.
						$hashedPassword = $hasher->HashPassword('my super cool password');

						// You can now safely store the contents of $hashedPassword in your database!

						// Check if a user has provided the correct password by comparing what they typed with our hash
						$hasher->CheckPassword('the wrong password', $hashedPassword); // false

						$hasher->CheckPassword('my super cool password', $hashedPassword); // true
						?&gt;</code>
					<h4>더 읽을거리</h4>
					<ul>
						<li><a href="http://www.openwall.com/phpass/">phpass</a></li>
					</ul>
					<h4>참고</h4>
					<ul>
						<li>PHP 새 버전의 <code>password_hash()</code>과 똑같이 phpass도 비밀번호에 salt값을 추가해줍니다.</li>
					</ul>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="mysql">
				<h2>MySQL 데이터베이스에 연결하고 쿼리하기</h2>
				<h3><a href="http://php.net/book.pdo">PDO</a>와 Prepared Statement 기능을 사용하세요.</h3>
                <p>PHP로 MySQL 데이터베이스에 연결하는 방법은 많습니다. <a href="http://php.net/manual/en/book.pdo.php">PDO</a> (PHP Data Objects)는 최신이면서 강력한 방법입니다. PDO는 여러 종류의 데이터베이스에 객체지향 접근법을 사용하여 일관된 인터페이스를 가지며, 새로나온 데이터베이스들의 더 많은 기능도 지원합니다.</p>
                <p>SQL 인젝션 공격을 방지하기 위해서 PDO의 Prepared Statement 기능을 사용해야합니다. <code><a href="http://php.net/pdostatement.bindvalue">bindValue()</a></code> 함수를 사용하여 여러분의 SQL이 일차적인 SQL 인젝션 공격에서 안전하도록 하세요. (이것이 100% 안전한 것을 보장하지는 않습니다. 이에 관해서는 <a href="#pdo-further-reading">더 읽을거리</a>를 참고하세요.) 과거에는 "magic quote" 함수들을 조합하여 위험을 방지해야했지만, PDO가 그 모든 지저분한 일을 할 필요없게 했습니다.</p>
				<h4>예제</h4>
				<code class="php">
					&lt;?php
					try{
						// Create a new connection.
						// You'll probably want to replace hostname with localhost in the first parameter.
						// Note how we declare the charset to be utf8mb4.  This alerts the connection that we'll be passing UTF-8 data.  This may not be required depending on your configuration, but it'll save you headaches down the road if you're trying to store Unicode strings in your database.  See "Gotchas".
						// The PDO options we pass do the following:
						// \PDO::ATTR_ERRMODE enables exceptions for errors.  This is optional but can be handy.
						// \PDO::ATTR_PERSISTENT disables persistent connections, which can cause concurrency issues in certain cases.  See "Gotchas".
						$link = new \PDO(	'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4',
											'your-username',
											'your-password',
											array(
												\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
												\PDO::ATTR_PERSISTENT => false
											)
										);

						$handle = $link->prepare('select Username from Users where UserId = ? or Username = ? limit ?');

						// PHP bug: if you don't specify PDO::PARAM_INT, PDO may enclose the argument in quotes.  This can mess up some MySQL queries that don't expect integers to be quoted.
						// See: https://bugs.php.net/bug.php?id=44639
						// If you're not sure whether the value you're passing is an integer, use the is_int() function.
						$handle->bindValue(1, 100, PDO::PARAM_INT);
						$handle->bindValue(2, 'Bilbo Baggins');
						$handle->bindValue(3, 5, PDO::PARAM_INT);

						$handle->execute();

						// Using the fetchAll() method might be too resource-heavy if you're selecting a truly massive amount of rows.
						// If that's the case, you can use the fetch() method and loop through each result row one by one.
						// You can also return arrays and other things instead of objects.  See the PDO documentation for details.
						$result = $handle->fetchAll(\PDO::FETCH_OBJ);

						foreach($result as $row){
							print($row->Username);
						}
					}
					catch(\PDOException $ex){
						print($ex->getMessage());
					}
					?&gt;</code>
				<h4>참고</h4>
				<ul>
                    <li>정수형 변수를 바인딩할때 <code>PDO::PARAM_INT</code> 매개변수를 전달하지 않으면 PDO가 종종 따옴표를 추가합니다. 이것은 특정한 MySQL 쿼리를 엉망으로 만들 수 있습니다. <a href="https://bugs.php.net/bug.php?id=44639">이 버그 리포트</a>를 참고하세요.</li>
                    <li>연결 문자열에 캐릭터 셋을 utf8mb4로 지정하지 않으면, 설정에 따라서 데이터베이스에 유니코드 데이터가 잘못 저장될 수 있습니다.</li>
                    <li>캐릭터 셋을 utf8mb4로 선언했더라도, 실제 데이터베이스 테이블이 utf8mb4 캐릭터 셋으로 되어있는지 확인해야합니다. utf8이 아니라 utf8mb4를 사용하는 이유에 대해서는 <a href="#utf-8">PHP와 UTF-8</a> 항목을 참고하세요.</li>
                    <li>Persistent 연결을 활성화하면 이상한 동시성 문제가 발생할 수 있습니다. 이것은 PHP 문제가 아니고, 애플리케이션 단의 문제입니다. Persistent 연결은 결과를 잘 알고 사용해야 안전합니다. <a href="http://stackoverflow.com/questions/3332074/what-are-the-disadvantages-of-using-persistent-connection-in-pdo">이 스택오버플로우 질문</a>을 참고하세요.</li>
                    <li>하나의 <code>execute()</code> 호출에 한개 이상의 SQL문을 실행할 수 있습니다. 그저 세미콜론으로 문장 사이를 구분해주세요. <b>Ubuntu 12.04 (PHP &lt;= 5.3.10)</b>에서는 이렇게 할 경우 <a href="https://bugs.php.net/bug.php?id=61207">이 버그</a>를 조심하세요. Ubuntu 12.04에 제공되는 PHP에서는 고쳐지지 않았습니다.</li>
				</ul>
				<h4 id="pdo-further-reading">더 읽을거리</h4>
				<ul>
					<li><a href="http://php.net/book.pdo">PHP Manual: PDO</a></li>
					<li><a href="http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/">Why you should be using PHP's PDO for database access</a></li>
					<li><a href="http://stackoverflow.com/questions/1402017/php-pdo-vs-normal-mysql-connect">Stack Overflow: PHP PDO vs normal mysql_connect</a></li>
					<li><a href="http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection">Stack Overflow: Are PDO prepared statements sufficient to prevent SQL injection?</a></li>
					<li><a href="https://stackoverflow.com/questions/1650591/whether-to-use-set-names">Stack Overflow: Whether to use "SET NAMES"</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="php-tags">
				<h2>PHP 태그</h2>
				<h3>&lt;?php ?&gt;를 사용하세요.</h3>
				<p>PHP 구역을 정하는 방법은 다음과 같은 몇가지 방법이 있습니다. <code>&lt;?php ?&gt;</code>, <code>&lt;?= ?&gt;</code>, <code>&lt;? ?&gt;</code>, <code>&lt;% %&gt;</code>. 짧은 것이 입력하기에는 더 편리하겠지만, 모든 PHP 서버에서 동작하는 것을 보장하는 것은 <code>&lt;?php ?&gt;</code> 뿐입니다. PHP 코드를 여러분이 통제할 수 없는 서버에 배포할 계획이라면, 반드시 <code>&lt;?php ?&gt;</code>를 사용하세요.</p>
				<p>여러분을 위해서 코딩하면서 사용하는 PHP 설정을 통제할 수 있다면, 짧은 태그가 편리할 수 있습니다. 하지만 <code>&lt;? ?&gt;</code>는 XML 선언과 겹치고, <code>&lt;% %&gt;</code>는 사실 ASP 스타일입니다.</p>
				<p>무엇을 선택하든지, 한가지로 일관되게 사용하세요!</p>
				<h4>참고</h4>
				<ul>
					<li>순수한 PHP 파일(클래스 정의만 담은 파일 등)에서 <code>?&gt;</code> 태그와 같은 닫는 태그를 사용할때, <em>태그 뒤에 빈줄이 들어가지 않도록 하세요.</em>. PHP 파서가 닫는 태그 뒤의 하나의 줄바꿈 문자를 안전하게 "먹어버리지만", 남은 줄바꿈 문자들은 브라우저에 출력될 수 있고, HTTP 헤더를 나중에 출력할 경우에 문제가 될 수 있습니다.</li>
					<li>옛 버전의 IE를 대상으로 한다면, <code>?&gt;</code> 태그와 HTML <code>&lt;!doctype&gt;</code> 태그 사이에 빈 줄이 들어가지 않도록 해야합니다. doctype 선언 전에 줄바꿈과 같은 공백이 나오면, 옛 버전의 IE는 <a href="http://www.quirksmode.org/css/quirksmode.html">쿼크 모드</a>로 동작합니다. 최근 버전의 IE와 다른 브라우저에서는 문제가 되지 않습니다.</li>
				</ul>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://stackoverflow.com/questions/200640/are-php-short-tags-acceptable-to-use">Stack Overflow: Are PHP short tags acceptable to use?</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="auto-loading">
				<h2>클래스 오토로딩(Auto-loading)</h2>
				<h3><code><a href="http://php.net/function.spl-autoload-register">spl_autoload_register()</a></code>를 사용해서 오토로딩 함수(auto-load function)를 등록하세요.</h3>
				<p>PHP는 아직 읽어오지 않은 클래스를 포한한 파일을 자동으로 불러오는 몇가지 방법을 제공합니다. 오래된 방법은 매직 전역 함수(magic global function)인 <code><a href="http://php.net/function.autoload">__autoload()</a></code>를 사용하는 것입니다. 하지만 한번에 하나의  <code>__autoload()</code> 함수만을 정의할 수 있어서 <code>__autoload()</code> 함수를 사용하는 라이브러리를 포함시키면, 충돌을 일으키게 됩니다.</p>
				<p>이런 문제를 해결하는 올바른 방법은 오토로딩 함수를 뭔가 고유한 이름으로 만들고, 이것을 <code><a href="http://php.net/function.spl-autoload-register">spl_autoload_register()</a></code> 함수를 사용하여 등록하는 것입니다. 이 함수는 하나 이상의 <code>__autoload()</code> 함수를 정의하는 것을 허용하기 때문에, 다른 코드의 <code>__autoload()</code> 함수에 문제를 일으킬 우려가 없습니다.</p>
				<h4>예제</h4>
				<code class="php">
					&lt;?php
					// First, define your auto-load function.
					function MyAutoload($className){
						include_once($className . '.php');
					}

					// Next, register it with PHP.
					spl_autoload_register('MyAutoload');

					// Try it out!
					// Since we haven't included a file defining the MyClass object, our auto-loader will kick in and include MyClass.php.
					// For this example, assume the MyClass class is defined in the MyClass.php file.
					$var = new MyClass();
					?&gt;</code>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://php.net/manual/en/function.spl-autoload-register.php">PHP Manual: spl_autoload_register()</a></li>
					<li><a href="http://stackoverflow.com/questions/791899/efficient-php-auto-loading-and-naming-strategies">Stack Overflow: Efficient PHP auto-loading and naming strategies</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="quotes">
				<h2>성능 관점에서의 작은 따옴표와 큰 따옴표</h2>
				<h3>사실 별 상관없습니다.</h3>
				<p>문자열을 정의할때 작은 따옴표(')를 사용할지, 큰 따옴표(")를 사용할지에 대해 많은 잉크가 쓰였습니다. 작은 따옴표로 묶인 문자열은 해석되지 않아서 문자열에 적힌 그대로 표시됩니다. 큰 따옴표로 묶인 문자열은 해석되어 문자열 내에 있는 PHP 변수들은 모두 평가(evaluated)됩니다. 줄바꿈을 위한 \n이나 탭을 위한 \t와 같은 이스케이프 문자는 작은 따옴표로 묶인 문자열에서는 <i>평가되지 않지만</i>, 큰 따옴표로 묶인 문자열에서는 <i>평가됩니다</i>.</p>
				<p>큰 따옴표로 묶인 문자열은 실행 시간에 평가되기 때문에, 이론적으로는 작은 따옴표로 묶인 문자열은 평가할 필요가 없어서 성능을 향상시킨다고 합니다. 어느 정도의 규모에서는 사실일지도 모르지만, 평범한 현실적인 애플리케이션에서의 차이는 아무 의미 없을 정도로 작습니다. 그래서 보통의 애플리케이션에서는 무엇을 사용하든지 상관없습니다. <em>극단적으로</em> 부하가 심한 애플리케이션에서는 영향이 약간 있을 수도 있습니다. 여러분의 애플리케이션의 필요에 맞게 선택하시고, 어떤 것을 선택하든지 일관되게 사용하세요.</p>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://php.net/language.types.string">PHP Manual: Strings</a></li>
					<li><a href="http://phpbench.com/">The PHP Benchmark</a> (Scroll down to Quote Types)</li>
					<li><a href="http://stackoverflow.com/questions/482202/is-there-a-performance-benefit-single-quote-vs-double-quote-in-php">Stack Overflow: Is there a performance benefit to single quotes vs double quotes in PHP?</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="constants">
				<h2><code>define()</code>과 <code>const</code></h2>
				<h3>클래스 상수나 가독성, 세부 최적화(micro-optimization)를 고려하는 경우가 아니라면, <code><a href="http://php.net/function.define">define()</a></code> 을 사용하세요.</h3>
				<p>PHP에서는 통상적으로 <code><a href="http://php.net/function.define">define()</a></code> 함수를 사용하여 상수를 정의했습니다. 하지만 어느 시점에 PHP에는 <code><a href="http://php.net/manual/en/language.oop5.constants.php">const</a></code> 키워드를 사용하여 상수를 정의하는 기능이 추가되었습니다. 상수를 정의할 때에 어떤 방법을 선택해야할까요?</p>
				<p>정답은 두 방법의 작은 차이에 있습니다.</p>
				<ol>
					<li><code>define()</code>은 상수를 실행 시간에 정의하지만, <code>const</code>는 컴파일 시간에 정의합니다. 이렇게 해서 <code>const</code>가 아주 조금은 빠르겠지만, 큰 규모의 소프트웨어를 만드는 것이 아니라면 아무도 신경쓰지 않을 정도입니다.</li>
					<li>상수 이름에 네임스페이스(namespaces)를 포함시킬 수도 있겠지만, <code>define()</code>은 상수를 전역 상수로 만듭니다. 즉, <code>define()</code>을 사용해서 클래스 상수를 만드는 것은 불가능합니다.</li>
					<li><code>define()</code>은 상수 이름과 상수값 모두에 표현식(expressions)을 사용할 수 있지만, <code>const</code>는 모두 사용할 수 없습니다. 이 때문에 <code>define()</code>이 훨씬 유연합니다.</li>
					<li><code>define()</code>은 <code>if()</code> 블록 안에 있을 수 있지만, <code>const</code>는 불가능합니다.</li>
				</ol>
				<h4>예제</h4>
				<code class="php">
					&lt;?php
					// Let's see how the two methods treat namespaces
					namespace MiddleEarth\Creatures\Dwarves;
					const GIMLI_ID = 1;
					define('MiddleEarth\Creatures\Elves\LEGOLAS_ID', 2);

					echo(\MiddleEarth\Creatures\Dwarves\GIMLI_ID);	// 1
					echo(\MiddleEarth\Creatures\Elves\LEGOLAS_ID);	// 2; note that we used define(), but the namespace is still recognized

					// Now let's declare some bit-shifted constants representing ways to enter Mordor.
					define('TRANSPORT_METHOD_SNEAKING', 1 &lt;&lt; 0); // OK!
					const TRANSPORT_METHOD_WALKING = 1 &lt;&lt; 1; // Compile error! const can't use expressions as values

					// Next, conditional constants.
					define('HOBBITS_FRODO_ID', 1);

					if($isGoingToMordor){
						define('TRANSPORT_METHOD', TRANSPORT_METHOD_SNEAKING); // OK!
						const PARTY_LEADER_ID = HOBBITS_FRODO_ID // Compile error: const can't be used in an if block
					}

					// Finally, class constants
					class OneRing{
						const MELTING_POINT_CELSIUS = 1000000; // OK!
						define('MELTING_POINT_ELVISH_DEGREES', 200); // Compile error: can't use define() within a class
					}
					?&gt;</code>
				<p><code>define()</code>은 매우 유연하기 때문에, 특별히 클래스 상수가 필요한 경우가 아니라면 골치아픈 문제를 피하기 위해서 <code>define()</code>을 사용하는게 좋습니다. <code>const</code>는 보통 읽기좋은 코드를 만들기는 하지만, 대신에 유연성을 포기해야합니다.</p>
				<p>어느 쪽은 선택하든지 일관되게 사용하세요!</p>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://stackoverflow.com/questions/2447791/define-vs-const">Stack Overflow: define() vs const</a></li>
					<li><a href="http://php.net/language.constants">PHP: 상수 - Manual</a></li>
					<li><a href="http://stackoverflow.com/questions/1225082/define-vs-variable-in-php">Stack Overflow: define() vs variable</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="opcode-cache">
				<h2>PHP opcode 캐시</h2>
				<h3>운 좋게도, PHP는 내장 opcode 캐시가 있습니다!</h3>
				<p>옛 버전의 PHP에서는 스크립트를 매번 실행할때마다 이전에 컴파일한 적이 있다고 해도 처음부터 컴파일해야만 했습니다. Opcode 캐시는 이전에 컴파일된 PHP 코드를 저장하여 속도를 약간 높여주는 부가 소프트웨어였습니다. 골라서 사용할 수 있는 여러 종류의 캐시가 있었습니다.</p>
				<p>운 좋게도, Ubuntu 14.04에 포함된 버전의 PHP에는 <em>내장 opcode 캐시가 내장되어</em> 기본적으로 활성화되어 있습니다. 그래서 아무것도 할 필요가 없습니다!</p>
				<p>캐시가 내장되지 않은 Ubuntu 12.04에서 opcode 캐시를 사용하기 위한 방법은 기록을 위해서 아래에 제공합니다.</p>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://php.net/book.opcache">PHP: Opcache - Manual</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)</h3>
					<h3><a href="http://php.net/book.apc">APC</a>를 opcode 캐시로 사용하세요.</h3>
					<p>사용할 수 있는 여러 PHP opcode 캐시들이 있는데, 특히 <a href="http://sourceforge.net/projects/eaccelerator/">eaccelerator</a>나, <a href="http://xcache.lighttpd.net/">xcache</a>, <a href="http://php.net/book.apc">APC</a> 등이 있습니다. APC는 PHP 프로젝트에서 공식적으로 지원하여 가장 활발하게 개발되고 있고, 설치하기 가장 간편합니다. 또한 부가적으로 <a href="http://memcached.org/">memcached</a>와 비슷한 키-값 저장소(persistent key-value store)를 제공합니다. 이런 이유로 APC를 사용하세요.</p>
					<h4>APC 설치하기</h4>
					<p>Ubuntu 12.04 터미널에서 아래 명령어를 입력하여 APC를 설치할 수 있습니다.</p>
					<code class="terminal">sudo apt-get install php-apc</code>
					<p>더 이상의 설정은 필요없습니다.</p>
					<h4>참고</h4>
					<ul>
						<li><a href="#serving-php">PHP-FPM</a>를 사용하지 않는 경우(<a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a>나 <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a>를 사용하는 경우), 각 PHP 프로세스는 각각 고유한 키-값 저장소를 포함한 APC 인스턴스를 가지게 됩니다. 주의하지 않으면 여러분의 애플리케이션 코드에 동기화 문제를 일으킬 수 있습니다.</li>
					</ul>
					<h4>더 읽을거리</h4>
					<ul>
						<li><a href="http://php.net/book.apc">PHP: APC - Manual</a></li>
					</ul>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="memcached">
				<h2>PHP와 Memcached</h2>
				<h3>분산형 캐시가 필요하다면, <a href="http://php.net/book.memcached">Memcached</a> 클라이언트 라이브러리를 사용하세요. 아니면, <a href="http://pecl.php.net/package/APCu">APCu</a>를 사용하세요.</h3>
				<p>캐싱 시스템은 애플리케이션의 성능을 향상시킬 수 있습니다. <a href="http://memcached.org/">Memcached</a>는 PHP를 포함한 많은 언어에서 동작하는 인기있는 선택지입니다.</p>
				<p>하지만, Memcached 서버를 PHP 스크립트에서 접근하려고 하면, 여러분에게는 아주 바보같은 이름의 두가지 클라이언트 중에 하나를 고를 수 있습니다. <a href="http://php.net/book.memcache">Memcache</a>와 <a href="http://php.net/book.memcached">Memcached</a>가 그것입니다. 둘은 거의 같은 이름을 가진 전혀 다른 라이브러리로 둘다 Memcached 인스턴스에 접근하는데 사용합니다.</p>
				<p>Memcache<u>d</u> 라이브러리가 Memcached 프로토콜을 가장 잘 구현한 라이브러리로 알려졌습니다. Memcache 라이브러리에는 없는 몇가지 유용한 기능을 포함하고 있고, 가장 활발하게 개발되고 있는 것 같습니다.</p>
				<p>하지만, 분산된 서버들에서 Memcached 인스턴스에 접근하는 것이 아니라면, <a href="http://pecl.php.net/package/APCu">대신 APCu를 사용하세요</a>. APCu는 PHP 프로젝트에 의해서 지원되고 Memcached와 거의 같은 기능을 제공합니다.</p>
				<h4>Memached 클라이언트 라이브러리 설치하기</h4>
				<p>Memcached 서버를 설치하고나면, Memcached 클라이언트 라이브러리를 설치해야합니다. 라이브러리없이는 PHP 스크립트가 Memcached 서버와 통신할 수 없습니다.</p>
				<p>Ubuntu 14.04에서 다음 명령을 터미널에 실행하면 Memcached 클라이언트 라이브러리를 설치할 수 있습니다.</p>
				<code class="terminal">sudo apt-get install php5-memcached</code>
				<h4>APCu를 사용하기</h4>
				<p>Ubuntu 14.04 이전에는 APC 프로젝트에 opcode 캐시와 Memcached와 비슷한 키-값 저장소 <em>둘 다</em> 있었습니다. 14.04에 포함된 PHP 버전부터는 <a href="#opcode-cache">내장 opcode 캐시를 포함하고</a>, APC는 opcode 캐시 기능을 제외한 ("user cahce"나 APCu의 "u"라고도 하는) APC의 키-값 저장소 기능만 APCu 프로젝트로 분리되었습니다.</p>
				<h4>APCu 설치하기</h4>
				<p>Ubuntu 14.04에서 다음 명령을 터미널에 실행하면 APCu를 설치할 수 있습니다.</p>
				<code class="terminal">sudo apt-get install php5-apcu</code>
				<h4>예제</h4>
				<code class="php">
					&lt;?php
					// Store some values in the APCu cache.  We can optionally pass a time-to-live, but in this example the values will live forever until they're garbage-collected by APCu.
					apc_store('username-1532', 'Frodo Baggins');
					apc_store('username-958', 'Aragorn');
					apc_store('username-6389', 'Gandalf');

					// After storing these values, any PHP script can access them, no matter when it's run!
					$value = apc_fetch('username-958', $success);
					if($success === true)
						print($value); // Aragorn

					$value = apc_fetch('username-1', $success); // $success will be set to boolean false, because this key doesn't exist.
					if($success !== true) // Note the !==, this checks for true boolean false, not "falsey" values like 0 or empty string.
						print('Key not found');

					apc_delete('username-958'); // This key will no longer be available.
					?&gt;</code>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://php.net/book.memcached">PHP: Memcached - Manual</a></li>
					<li><a href="http://pecl.php.net/package/APCu">PECL: APCu</a></li>
					<li><a href="http://stackoverflow.com/questions/1442411/using-memcache-vs-memcached-with-php">Stack Overflow: Using Memcache vs Memcached with PHP</a></li>
					<li><a href="http://stackoverflow.com/questions/815041/memcached-vs-apc-which-one-should-i-choose">Stack Overflow: Memcached vs APC, which one should I choose?</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)</h3>
					<h3>Memcached 대신에 <a href="http://php.net/book.apc">APC</a>를 사용하세요.</h3>
					<p>Ubuntu 12.04에서 키-값 저장소와 opcode 캐시로 APC를 사용한다면, (APC와 APCu는 API가 동일하기때문에) 위의 예제도 잘 동작합니다.</p>
					<p>Ubuntu 12.04에 APC를 설치하는 방법에 대해서는 <a href="#opcode-cache">opcode 캐시 부분</a>을 참고하세요.</p>
					<h4>더 읽을거리</h4>
					<ul>
						<li><a href="http://php.net/book.apc">PHP: APC - Manual</a></li>
					</ul>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="regex">
				<h2>PHP와 정규표현식</h2>
				<h3><a href="http://php.net/book.pcre">PCRE</a> (<code>preg_*</code>) 함수들을 사용하세요.</h3>
				<p>PHP는 정규표현식을 사용하는 두가지 방법을 제공합니다. <a href="http://php.net/manual/en/book.pcre.php">PCRE</a> (Perl 호환, <code>preg_*</code>) 함수와 <a href="http://php.net/manual/en/book.regex.php">POSIX</a> (POSIX 확장, <code>ereg_*</code>) 함수입니다.</p>
				<p>각 종류의 함수들은 약간 다른 형태의 정규표현식을 사용합니다. 운 좋게도, PHP 5.3.0부터 POSIX 함수들은 deprecated 되었습니다. 그래서, 새로 작성하는 코드는 POSIX 함수로 작성해서는 안됩니다. PCRE 함수(<code>preg_*</code> 함수)를 사용하세요.</p>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://php.net/book.pcre">PHP: PCRE - Manual</a></li>
					<li><a href="http://www.noupe.com/php/php-regular-expressions.html">Getting started with PHP regular expressions</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="serving-php">
				<h2>웹서버에 PHP 올리기</h2>
				<h3><a href="http://php.net/install.fpm">PHP-FPM</a>를 사용하세요.</h3>
                <p>PHP를 사용하기 위해서 웹서버를 설정하는 여러가지 방법이 있습니다. 전통적(이고 끔찍한) 방법은 Apache의 <a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a>를 사용하는 것입니다. Mod_php는 PHP를 Apache 자체에 연결해주지만, Apache는 제대로 관리하지 못합니다. 실제 트래픽을 감당하게 되자마자 심각한 메모리 문제를 격게 될 겁니다.</p>
				<p>다음 두 가지 새로운 선택이 빠르게 인기를 얻었습니다. 그것은 <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a>와 <a href="http://httpd.apache.org/mod_fcgid/">mod_fcgid</a>입니다. 두 가지 모두 제한된 수의 PHP 프로세스를 실행하고, Apache가 요청을 이 인터페이스에 보내서, 이것들이 PHP 실행을 관리하도록 합니다. 이 라이브러리들이 실행할 PHP 프로세스 수를 제한하기 때문에 성능에 영향을 미치지 않으면서 메모리 사용량을 크게 줄일 수 있습니다.</p>
                <p>어느 똑똑한 사람들이 특별히 PHP와 아주 잘 동작하도록 설계된 fastcgi의 구현을 만들었는데, 그 이름은 <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>입니다. 12.04 이후로 이것이 웹서버를 위한 표준 솔루션입니다.</p>
                <p>Ubuntu 12.04 출시 몇 년 후에, Apache는 PHP-FPM와 연동할 새로운 방법을 내놓았는데, 바로 <a href="http://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a>입니다. 안타깝지만 Ubuntu 14.04에 포함된 Apache 버전에는 이 모듈에 약간 문제가 있습니다. 소켓 기반의 연결을 사용할 수 없고, mod_rewrite관련 이슈와, 404와 같은 페이지에 문제(issues with 404 and similar pages)가 있습니다. 따라서, Ubuntu 12.04에서 사용했던 검증된 PHP-FPM 사용법을 사용하세요.</p>
                <p>아래 예제는 Apache 2.4.7을 위한 것이지만, PHP-FPM는 Nginx와 같은 다른 웹서버들과도 동작합니다.</p>
				<h4>PHP-FPM과 Apache 설치하기</h4>
                <p>아래 명령어를 터미널에서 실행하여 Ubuntu 14.04에 PHP-FPM과 Apache를 설치할 수 있습니다.</p>
				<code class="terminal multiline">
						<span>sudo apt-get install apache2-mpm-event libapache2-mod-fastcgi php5-fpm</span>
						<span>sudo a2enmod actions alias fastcgi</span>
					</code>
                <p><em>반드시</em> apache2-mpm-event (혹은 apache2-mpm-worker)를 사용하고, apache2-mpm-prefork나 apache2-mpm-threaded를 사용해서는 <em>안된다</em>는 것에 주의하세요.</p>
                <p>다음으로는, PHP 요청을 PHP-FPM으로 라우팅할 Apache 가상호스트를 설정합니다. 아래 내용을 Apache 설정파일에 넣으세요. (Ubuntu 14.04의 기본 설정 위치는 /etc/apache2/sites-available/000-default.conf).</p>
				<code class="php">
					&lt;Directory /&gt;
						Require all granted
					&lt;/Directory&gt;
					&lt;VirtualHost *:80&gt;
						Action php5-fcgi /php5-fcgi
						Alias /php5-fcgi /usr/lib/cgi-bin/php5-fcgi
						FastCgiExternalServer /usr/lib/cgi-bin/php5-fcgi -socket /var/run/php5-fpm.sock -idle-timeout 120 -pass-header Authorization
						&lt;FilesMatch "\.php$"&gt;
							SetHandler	php5-fcgi
						&lt;/FilesMatch&gt;
					&lt;/VirtualHost&gt;</code>
				<p>마지막으로, Apache와 FPM 프로세스를 재시작합니다.</p>
				<code class="terminal">sudo service apache2 restart && sudo service php5-fpm restart</code>
				<h4>참고</h4>
				<ul>
                    <li><code><a href="http://httpd.apache.org/docs/2.4/mod/core.html#sethandler">SetHandler</a></code> 디렉티브(directive) 대신에 <code><a href="http://httpd.apache.org/docs/2.4/mod/mod_mime.html#addhandler">AddHandler</a></code> 디렉티브를 사용하는 것은 보안 위험이 있습니다. <code>AddHandler</code>는 ".php"를 <em>파일 이름 중 어디에든 포함한</em> 파일 안의 PHP 코드를 실행할 것 입니다. 그래서 사용자가 파일 업로드 폼(form)을 사용해서 evil.php.gif 파일을 업로드 하면, 예기치못한 불쾌한 일을 당할지도 모릅니다.</li>
				</ul>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://php.net/install.fpm">PHP: PHP-FPM - Manual</a></li>
					<li><a href="http://php-fpm.org">PHP-FPM homepage</a></li>
					<li><a href="https://alexcabal.com/installing-apache-mod_fastcgi-php-fpm-on-ubuntu-server-maverick/">Installing Apache + mod_fastcgi + PHP-FPM on Ubuntu Server Maverick</a></li>
					<li><a href="http://www.joomlaperformance.com/articles/webcasts/why_mod_php_is_bad_for_performance_52_58.html">Why mod_php is bad for performance</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (Apache 2.2.22)</h3>
                    <p>Ubuntu 12.04를 위한 설정은, <code>&lt;Directory&gt;</code> 블록을 설정파일에 포함하지 않는 것만 제외하고 위와 같습니다.</p>
                    <p>Apache 2.2.22 의 기본 사이트 설정은 /etc/apache2/sites-available/default 에 있습니다.</p>
                    <p>Apache 2.2.22는 안정적인 event MPM이 없기 때문에, apache2-mpm-event 대신에 apache2-mpm-worker를 설치하세요.</p>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="email">
				<h2>이메일 보내기</h2>
				<h3><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a>를 사용하세요.</h3>
				<p><em><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a> 5.2.7</em>로 테스트 되었음.</p>
				<p>PHP는 매우 간단하고 쉬운 <code><a href="http://php.net/function.mail">mail()</a></code> 함수를 제공합니다. 유감스럽게도 PHP에 있는 다른 많은 것처럼, 그 단순함에 현혹되어, 있는 그대로 사용했다가는 심각한 보안 문제를 일으킬 수 있습니다.</p>
				<p>이메일은 PHP보다도 훨씬 많은 고난의 역사를 가진 프로토콜 세트입니다. PHP의 <code>mail()</code> 함수가 여러분을 오싹하게 만드는 정도로 메일을 발송하는 것은 많은 어려움이 있다고 말하면 적당할 것입니다.</p>
				<p><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a>는 메일을 안정적으로 발송하기 위하여 쉬운 인터페이스를 제공하는 유명하고 잘 숙성된(well-aged) 오픈소스 라이브러리입니다. PHPMailer는 모든 어려운 일들을 처리해서 여러분이 좀더 중요한 일에 집중할 수 있도록 해줍니다.</p>
				<h4>예제</h4>
				<code class="php">
					&lt;?php
					// Include the PHPMailer library
					require_once('phpmailer-5.2.7/PHPMailerAutoload.php');

					// Passing 'true' enables exceptions.  This is optional and defaults to false.
					$mailer = new PHPMailer(true);

					// Send a mail from Bilbo Baggins to Gandalf the Grey

					// Set up to, from, and the message body.  The body doesn't have to be HTML; check the PHPMailer documentation for details.
					$mailer->Sender = 'bbaggins@example.com';
					$mailer->AddReplyTo('bbaggins@example.com', 'Bilbo Baggins');
					$mailer->SetFrom('bbaggins@example.com', 'Bilbo Baggins');
					$mailer->AddAddress('gandalf@example.com');
					$mailer->Subject = 'The finest weed in the South Farthing';
					$mailer->MsgHTML('&lt;p&gt;You really must try it, Gandalf!&lt;/p&gt;&lt;p&gt;-Bilbo&lt;/p&gt;');

					// Set up our connection information.
					$mailer->IsSMTP();
					$mailer->SMTPAuth = true;
					$mailer->SMTPSecure = 'ssl';
					$mailer->Port = 465;
					$mailer->Host = 'my smtp host';
					$mailer->Username = 'my smtp username';
					$mailer->Password = 'my smtp password';

					// All done!
					$mailer->Send();
					?&gt;</code>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer at Github</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="validating-emails">
				<h2>Validating email addresses</h2>
				<h3>Use the <code><a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a></code> function.</h3>
				<p>A common task your web app might need to do is to check if a user has entered a valid email address. You'll no doubt find online a dizzying range of complex regular expressions that all claim to solve this problem, but the easiest way is to use PHP's built-in <code><a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a></code> function, which can validate email addresses.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					filter_var('sgamgee@example.com', FILTER_VALIDATE_EMAIL); // Returns "sgamgee@example.com". This is a valid email address.
					filter_var('sauron@mordor', FILTER_VALIDATE_EMAIL); // Returns boolean false! This is *not* a valid email address.
					?&gt;</code>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/function.filter-var.php">PHP Manual: filter_var()</a></li>
					<li><a href="http://php.net/manual/en/filter.filters.php">PHP Manual: Types of filters</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="sanitizing-html">
				<h2>Sanitizing HTML input and output</h2>
				<h3>Use the <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> function for simple sanitization and the <a href="http://htmlpurifier.org/">HTML Purifier</a> library for complex sanitization.</h3>
				<p><em>Tested with <a href="http://htmlpurifier.org/">HTML Purifier</a> 4.6.0.</em></p>
				<p>When displaying user input in any web application, it's essential to "sanitize" it first to remove any potentially dangerous HTML. A malicious user can craft HTML that, if outputted directly by your web app, can be dangerous to the person viewing it.</p>
				<p>While it may be tempting to use regular expressions to sanitize HTML, <em>do not do this</em>. HTML is a complex language and it's virtually guaranteed that any attempt you make at using regular expressions to sanitize HTML will fail.</p>
				<p>You might also find advice suggesting you use the <code><a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a></code> function. While <code>strip_tags()</code> is technically safe to use, it's a "dumb" function in the sense that if the input is invalid HTML (say, is missing an ending tag), then strip_tags() might remove much more content than you expected. As such it's not a great choice either, because non-technical users often use the &lt; and &gt; characters in communications.</p>
				<p>If you read the section on <a href="#validating-emails">validating email addresses</a>, you might also be considering using the <code><a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a></code> function. However <a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">the <code>filter_var()</code> function has problems with line breaks</a>, and requires non-intuitive configuration to closely mirror the <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> function. As such it's not a good choice either.</p>
				<h4>Sanitization for simple requirements</h4>
				<p>If your web app only needs to completely escape (and thus render harmless, but not remove entirely) HTML, use PHP's built-in <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> function. This function is much faster than HTML Purifier, because it doesn't perform any validation on the HTML&mdash;it just escapes everything.</p>
				<p><code>htmlentities()</code> differs from its cousin <code><a href="http://php.net/manual/en/function.htmlspecialchars.php">htmlspecialchars()</a></code> in that it encodes <em>all</em> applicable HTML entities, not just a small subset.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
					$evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';

					// Use the ENT_QUOTES flag to make sure both single and double quotes are escaped.
					// Use the UTF-8 character encoding if you've stored the text as UTF-8 (as you should have).
					// See the UTF-8 section in this document for more details.
					$safeHtml = htmlentities($evilHtml, ENT_QUOTES, 'UTF-8'); // $safeHtml is now fully escaped HTML.  You can output $safeHtml to your users without fear!
					?&gt;</code>
				<h4>Sanitization for complex requirements</h4>
				<p>For many web apps, simply escaping HTML isn't enough. You probably want to entirely remove any HTML, or allow a small subset of HTML through. To do this, use the <a href="http://htmlpurifier.org/">HTML Purifier</a> library.</p>
				<p>HTML Purifier is a well-tested but slow library. That's why you should use <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> if your requirements aren't that complex, because it will be much, much faster.</p>
				<p>HTML Purifier has the advantage over <code><a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a></code> because it validates the HTML before sanitizing it. That means if the user has inputted invalid HTML, HTML Purifier has a better chance of preserving the intended meaning of the HTML than <code>strip_tags()</code> does. It's also highly customizable, allowing you to whitelist a subset of HTML to keep in the output.</p>
				<p>The downside is that it's quite slow, it requires some setup that might not be feasible in a shared hosting environment, and the documentation is often complex and unclear. The following example is a basic configuration; check the <a href="http://htmlpurifier.org/docs">documentation</a> to read about the more advanced features HTML Purifier offers.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Include the HTML Purifier library
					require_once('htmlpurifier-4.6.0/HTMLPurifier.auto.php');

					// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
					$evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';

					// Set up the HTML Purifier object with the default configuration.
					$purifier = new HTMLPurifier(HTMLPurifier_Config::createDefault());

					$safeHtml = $purifier->purify($evilHtml); // $safeHtml is now sanitized.  You can output $safeHtml to your users without fear!
					?&gt;</code>
				<h4>Gotchas</h4>
				<ul>
					<li>Using <code>htmlentities()</code> with the wrong character encoding can result in surprising output. Always make sure that you specify a character encoding when calling the function, and that it matches the encoding of the string being sanitized. See the <a href="#utf-8">UTF-8 section</a> for more details.</li>
					<li>Always include the <code>ENT_QUOTES</code> and character encoding parameters when using <code>htmlentities()</code>. By default, <code>htmlentities()</code> doesn't encode single quotes. What a dumb default!</li>
					<li>HTML Purifier is extremely slow for complex HTML. Consider setting up a caching solution like <a href="#opcode-cache">APC</a> to store the sanitized result for later use.</li>
				</ul>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://htmlpurifier.org/comparison">Comparison between PHP HTML sanitizers</a></li>
					<li><a href="http://stackoverflow.com/questions/3605629/php-prevent-xss-with-strip-tags">Stack Overflow: Prevent XSS with strip_tags()?</a></li>
					<li><a href="http://stackoverflow.com/questions/129677/whats-the-best-method-for-sanitizing-user-input-with-php">Stack Overflow: What's the best method for sanitizing user input with PHP?</a></li>
					<li><a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">Stack Overflow: FILTER_SANITIZE_SPECIAL_CHARS problem with line breaks</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="utf-8">
				<h2>PHP and UTF-8</h2>
				<h3>There's no one-liner.  Be careful, detailed, and consistent.</h3>
				<p>UTF-8 in PHP sucks. Sorry.</p>
				<p>Right now PHP does not support Unicode at a low level. There are ways to ensure that UTF-8 strings are processed OK, but it's not easy, and it requires digging in to almost all levels of the web app, from HTML to SQL to PHP. We'll aim for a brief, practical summary.</p>
				<h4>UTF-8 at the PHP level</h4>
				<p>The basic <a href="http://php.net/manual/en/language.operators.string.php">string operations</a>, like concatenating two strings and assigning strings to variables, don't need anything special for UTF-8. However most <a href="http://php.net/manual/en/ref.strings.php">string functions</a>, like <code><a href="http://php.net/manual/en/function.strpos.php">strpos()</a></code> and <code><a href="http://php.net/manual/en/function.strlen.php">strlen()</a></code>, <em>do</em> need special consideration. These functions often have an <code>mb_*</code> counterpart: for example, <code><a href="http://php.net/manual/en/function.mb-strpos.php">mb_strpos()</a></code> and <code><a href="http://php.net/manual/en/function.mb-strlen.php">mb_strlen()</a></code>. Together, these counterpart functions are called the <a href="http://php.net/manual/en/ref.mbstring.php">Multibyte String Functions</a>. The multibyte string functions are specifically designed to operate on Unicode strings.</p>
				<p>You <em>must</em> use the <code>mb_*</code> functions whenever you operate on a Unicode string. For example, if you use <code><a href="http://php.net/manual/en/function.substr.php">substr()</a></code> on a UTF-8 string, there's a good chance the result will include some garbled half-characters. The correct function to use would be the multibyte counterpart, <code><a href="http://php.net/manual/en/function.mb-substr.php">mb_substr()</a></code>.</p>
				<p>The hard part is remembering to use the <code>mb_*</code> functions <em>at all times</em>. If you forget even just once, your Unicode string has a chance of being garbled during further processing.</p>
				<p>Not all string functions have an <code>mb_*</code> counterpart. If there isn't one for what you want to do, then you might be out of luck.</p>
				<p>Additionally, you should use the <code><a href="http://php.net/manual/en/function.mb-internal-encoding.php">mb_internal_encoding()</a></code> function at the top of every PHP script you write (or at the top of your global include script), and the <code><a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a></code> function right after it if your script is outputting to a browser. Explicitly defining the encoding of your strings in every script will save you a lot of headaches down the road.</p>
				<p>Finally, many PHP functions that operate on strings have an optional parameter letting you specify the character encoding. You should always explicitly indicate UTF-8 when given the option. For example, <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> has an option for character encoding, and you should <em>always</em> specify UTF-8 if dealing with such strings.</p>
				<h4>UTF-8 at the MySQL level</h4>
				<p>If your PHP script accesses MySQL, there's a chance your strings could be stored as non-UTF-8 strings in the database even if you follow all of the precautions above.</p>
				<p>To make sure your strings go from PHP to MySQL as UTF-8, make sure your database and tables are all set to the utf8mb4 character set and collation, and that you use the utf8mb4 character set in the PDO connection string. For an example, see the section on <a href="#mysql">connecting to and querying a MySQL database</a>. This is <em>critically important</em>.</p>
				<p>Note that you must use the utf8mb4 character set for complete UTF-8 support, <em>not</em> the utf8 character set! See <a href="#utf8-further-reading">Further Reading</a> for why.</p>
				<h4>UTF-8 at the browser level</h4>
				<p>Use the <code><a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a></code> function to ensure that your PHP script outputs UTF-8 strings to your browser. In your HTML, include the <code><a href="http://htmlpurifier.org/docs/enduser-utf8.html">charset</a></code> meta tag in your page's <code>&lt;head&gt;</code> tag.
					<h4>Example</h4>
					<code class="php">
					&lt;?php
					// Tell PHP that we're using UTF-8 strings until the end of the script
					mb_internal_encoding('UTF-8');

					// Tell PHP that we'll be outputting UTF-8 to the browser
					mb_http_output('UTF-8');

					// Our UTF-8 test string
					$string = 'Êl síla erin lû e-govaned vîn.';

					// Transform the string in some way with a multibyte function
					// Note how we cut the string at a non-Ascii character for demonstration purposes
					$string = mb_substr($string, 0, 15);

					// Connect to a database to store the transformed string
					// See the PDO example in this document for more information
					// Note that we define the character set as utf8mb4 in the PDO connection string
					$link = new \PDO(	'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4',
										'your-username',
			 							'your-password',
										array(
											\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
											\PDO::ATTR_PERSISTENT => false
										)
									);

					// Store our transformed string as UTF-8 in our database
					// Your DB and tables are in the utf8mb4 character set and collation, right?
					$handle = $link->prepare('insert into ElvishSentences (Id, Body) values (?, ?)');
					$handle->bindValue(1, 1, PDO::PARAM_INT);
					$handle->bindValue(2, $string);
					$handle->execute();

					// Retrieve the string we just stored to prove it was stored correctly
					$handle = $link->prepare('select * from ElvishSentences where Id = ?');
					$handle->bindValue(1, 1, PDO::PARAM_INT);
					$handle->execute();

					// Store the result into an object that we'll output later in our HTML
					$result = $handle->fetchAll(\PDO::FETCH_OBJ);
					?&gt;&lt;!doctype html&gt;
					&lt;html&gt;
						&lt;head&gt;
							&lt;meta charset="UTF-8" /&gt;
							&lt;title&gt;UTF-8 test page&lt;/title&gt;
						&lt;/head&gt;
						&lt;body&gt;
							&lt;?php
							foreach($result as $row){
								print($row->Body);  // This should correctly output our transformed UTF-8 string to the browser
							}
							?&gt;
						&lt;/body&gt;
					&lt;/html&gt;</code>
					<h4 id="utf8-further-reading">Further reading</h4>
					<ul>
						<li><a href="http://php.net/manual/en/ref.mbstring.php">PHP Manual: Multibyte String Functions</a></li>
						<li><a href="http://blog.loftdigital.com/blog/php-utf-8-cheatsheet">PHP UTF-8 Cheatsheet</a></li>
						<li><a href="http://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible">Stack Overflow: What factors make PHP Unicode-incompatible?</a></li>
						<li><a href="http://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings">Stack Overflow: Best practices in PHP and MySQL with international strings</a></li>
						<li><a href="http://mathiasbynens.be/notes/mysql-utf8mb4">How to support full Unicode in MySQL databases</a></li>
					</ul>
					<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="working-with-dates-and-times">
				<h2>Working with dates and times</h2>
				<h3>Use the <a href="http://php.net/manual/en/class.datetime.php"><code>DateTime</code> class</a>.</h3>
				<p>In the bad old days of PHP we had to work with dates and times using a bewildering combination of <code><a href="http://php.net/manual/en/function.date.php">date()</a></code>, <code><a href="http://php.net/manual/en/function.gmdate.php">gmdate()</a></code>, <code><a href="http://php.net/manual/en/function.date-timezone-set.php">date_timezone_set()</a></code>, <code><a href="http://php.net/manual/en/function.strtotime.php">strtotime()</a></code>, and so on. Sadly you'll still find lots of tutorials online featuring these difficult and old-fashioned functions.</p>
				<p>Fortunately for us, the version of PHP we're talking about features the much friendlier <a href="http://php.net/manual/en/class.datetime.php"><code>DateTime</code> class</a>. This class encapsulates all the functionality <em>and more</em> of the old date functions in one easy-to-use class, with the bonus of making time zone conversions much simpler. Always use the <code>DateTime</code> class for creating, comparing, changing, and displaying dates in PHP.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Construct a new UTC date.  Always specify UTC unless you really know what you're doing!
					$date = new DateTime('2011-05-04 05:00:00', new DateTimeZone('UTC'));

					// Add ten days to our initial date
					$date->add(new DateInterval('P10D'));

					echo($date->format('Y-m-d h:i:s')); // 2011-05-14 05:00:00

					// Sadly we don't have a Middle Earth timezone
					// Convert our UTC date to the PST (or PDT, depending) time zone
					$date->setTimezone(new DateTimeZone('America/Los_Angeles'));

					// Note that if you run this line yourself, it might differ by an hour depending on daylight savings
					echo($date->format('Y-m-d h:i:s')); // 2011-05-13 10:00:00

					$later = new DateTime('2012-05-20', new DateTimeZone('UTC'));

					// Compare two dates
					if($date &lt; $later)
						echo('Yup, you can compare dates using these easy operators!');

					// Find the difference between two dates
					$difference = $date->diff($later);

					echo('The 2nd date is ' . $difference['days'] . ' later than 1st date.');
					?&gt;
					</code>
				<h4>Gotchas</h4>
				<ul>
					<li>
						<p>If you don't specify a time zone, <code><a href="http://php.net/manual/en/datetime.construct.php">DateTime::__construct()</a></code> will set the resulting date's time zone to <em>the time zone of the computer you're running on</em>. This can lead to spectacular headaches later on. <strong>Always specify the UTC time zone when creating new dates unless you really know what you're doing.</strong></p>
					</li>
					<li>
						<p>If you use a Unix timestamp in <code>DateTime::__construct()</code>, the time zone will always be set to UTC regardless of what you specify in the second argument.</p>
					</li>
					<li>
						<p>Passing zeroed dates (e.g. &quot;0000-00-00&quot;, a value commonly produced by MySQL as the default value in a DateTime column) to <code>DateTime::__construct()</code> will result in a nonsensical date, not &quot;0000-00-00&quot;.</p>
					</li>
					<li>
						<p>Using <code><a href="http://php.net/manual/en/datetime.gettimestamp.php">DateTime::getTimestamp()</a></code> on 32-bit systems will not represent dates past 2038. 64-bit systems are OK.</p>
					</li>
				</ul>
				<h4>Further Reading</h4>
				<ul>
					<li>
						<p><a href="http://php.net/manual/en/book.datetime.php">PHP Manual: The DateTime class</a></p>
					</li>
					<li>
						<p><a href="http://stackoverflow.com/questions/5319710/accessing-dates-in-php-beyond-2038">Stack Overflow: Accessing dates beyond 2038</a></p>
					</li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="checking-for-null">
				<h2>Checking if a value is null or false</h2>
				<h3>Use the <code><a href="http://php.net/manual/en/language.operators.comparison.php">===</a></code> operator to check for null and boolean false values.</h3>
				<p>PHP's loose typing system offers many different ways of checking a variable's value. However it also presents a lot of problems. Using <code><a href="http://php.net/manual/en/language.operators.comparison.php">==</a></code> to check if a value is null or false can return false positives if the value is actually an empty string or 0. <code><a href="http://php.net/manual/en/function.isset.php">isset()</a></code> checks whether a variable has a value, <em>not</em> whether that value is null or false, so it's not appropriate to use here.</p>
				<p>The <code><a href="http://php.net/manual/en/function.is-null.php">is_null()</a></code> function accurately checks if a value is null, and the <code><a href="http://php.net/manual/en/function.is-bool.php">is_bool()</a></code> function checks if it's a boolean value (like <code>false</code>), but there's an even better option: the <code><a href="http://php.net/manual/en/language.operators.comparison.php">===</a></code> operator. <code>===</code> checks if the values are <em>identical</em>, which is not the same as <em>equivalent</em> in PHP's loosely-typed world. It's also slightly faster than <code>is_null()</code> and <code>is_bool()</code>, and looks nicer than using a function for comparison.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					$x = 0;
					$y = null;

					// Is $x null?
					if($x == null)
						print('Oops! $x is 0, not null!');

					// Is $y null?
					if(is_null($y))
						print('Great, but could be faster.');

					if($y === null)
						print('Perfect!');

					// Does the string abc contain the character a?
					if(strpos('abc', 'a'))
						// GOTCHA!  strpos returns 0, indicating it wishes to return the position of the first character.
						// But PHP interpretes 0 as false, so we never reach this print statement!
						print('Found it!');

					//Solution: use !== (the opposite of ===) to see if strpos() returns 0, or boolean false.
					if(strpos('abc', 'a') !== false)
						print('Found it for real this time!');
					?&gt;</code>
				<h4>Gotchas</h4>
				<ul>
					<li>When testing the return value of a function that can return either 0 or boolean <code>false</code>, like <code>strpos()</code>, always use <code>===</code> and <code>!==</code>, or you'll run in to problems.</li>
				</ul>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/language.operators.comparison.php">PHP Manual: Comparison operators</a></li>
					<li><a href="http://stackoverflow.com/questions/8228837/is-nullx-vs-x-null-in-php">Stack Overflow: is_null() vs ===</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="suggestions">
				<h2>제안이나 수정사항</h2>
				<p>읽어주셔서 감사합니다! 여러분이 미리 알고있지 않는다면, PHP는 복잡하고 위험들로 가득 차있습니다. 저도 사람이기에 이 문서에 어떤 실수가 있을 수 있습니다.</p>
				<p>이 문서에 어떤 제안이나 수정할 것이 있으면, <a href="#maintainers">최신 개정판 &amp; 관리자</a> 항목의 정보를 참고하시고 저에게 연락주세요.</p>
				<p>한국어판 번역에 대한 제안이나 수정 사항은 <a href="https://github.com/meye/php-best-practices/issues">Github 저장소</a>에 이슈를 남겨주세요.</p>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
		</article>
	</main>
	<footer>
		<a rel="bookmark" href="/">PHP Best Practices</a> by <a rel="author" href="https://alexcabal.com">Alex Cabal</a> is released into the <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">public domain</a>. <a href="https://alexcabal.com/why-i-release-things-into-the-public-domain">Why?</a>
	</footer>
</body>

</html>
