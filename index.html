<!doctype html>
<html>

<head>
	<title>PHP Best Practices: 일반적이고 복잡한 PHP 작업을 위한 짧고 실용적인 가이드</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link type="text/css" rel="stylesheet" href="css/core.css" media="screen" />
	<link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCore.css" media="screen" />
	<link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCoreDefault.css" media="screen" />
	<script type="text/javascript" src="js/jquery/jquery-1.7.2.min.js"></script>
	<script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shCore.js"></script>
	<script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shBrushPhp.js"></script>
	<script type="text/javascript">
	$(document).ready(function() {
		$('code.php').attr('class', 'php brush: php');
		SyntaxHighlighter.config.tagName = 'code';
		SyntaxHighlighter.all()
	});
	</script>
	<script>
	// (function(i, s, o, g, r, a, m) {
	// 	i['GoogleAnalyticsObject'] = r;
	// 	i[r] = i[r] || function() {
	// 		(i[r].q = i[r].q || []).push(arguments)
	// 	}, i[r].l = 1 * new Date();
	// 	a = s.createElement(o),
	// 		m = s.getElementsByTagName(o)[0];
	// 	a.async = 1;
	// 	a.src = g;
	// 	m.parentNode.insertBefore(a, m)
	// })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
	//
	// ga('create', 'UA-35543520-1', 'phpbestpractices.org');
	// ga('send', 'pageview');
	</script>
</head>

<body>
	<header>
		<h1>PHP Best Practices</h1>
		<h2>일반적이고 복잡한 PHP 작업을 위한 짧고 실용적인 가이드</h2>
	</header>
	<main>
		<nav>
			<ol>
				<li><a href="#maintainers">최신 개정판 &amp; 관리자</a></li>
				<li><a href="#introduction">소개</a></li>
				<li><a href="#version">어떤 PHP 버전을 사용하나요?</a></li>
				<li><a href="#passwords">비밀번호 저장하기</a></li>
				<li><a href="#mysql">PHP and MySQL</a></li>
				<li><a href="#php-tags">PHP tags</a></li>
				<li><a href="#auto-loading">Auto-loading classes</a></li>
				<li><a href="#quotes">Single vs. double quotes</a></li>
				<li><a href="#constants">define() vs. const</a></li>
				<li><a href="#opcode-cache">Caching PHP opcode</a></li>
				<li><a href="#memcached">PHP and Memcached</a></li>
				<li><a href="#regex">PHP and regex</a></li>
				<li><a href="#serving-php">Serving PHP</a></li>
				<li><a href="#email">Sending email</a></li>
				<li><a href="#validating-emails">Validating email addresses</a></li>
				<li><a href="#sanitizing-html">Sanitizing HTML</a></li>
				<li><a href="#utf-8">PHP and UTF-8</a></li>
				<li><a href="#working-with-dates-and-times">Working with dates and times</a></li>
				<li><a href="#checking-for-null">Checking null and false values</a></li>
				<li><a href="#suggestions">Suggestions and corrections</a></li>
			</ol>
		</nav>
		<article>
			<h2>PHP Best Practices</h2>
			<section id="maintainers">
				<h2>최신 개정판 &amp; 관리자</h2>
				<p>이 문서는 2014년 7월 3일에 최종 확인했습니다. 2014년 7월 3일에 최종 수정되었습니다.</p>
				<p>이 문서는 저, <a href="https://alexcabal.com" rel="author">Alex Cabal</a>이 관리하고 있습니다. 저는 오랜 기간 PHP를 작성해왔고, 현재 <a href="http://www.scribophile.com/">진지한 작가를 위한 온라인 글쓰기 그룹인 Scribophile</a>, <a href="http://writerfolio.com">프리랜서를 위한 쉬운 온라인 글쓰기 포트폴리오인 Writerfolio</a>, <a href="https://standardebooks.com">삽화가 들어간 DRM없는 퍼블릭 도메인 eBook을 출판하는 Standard Ebooks</a> 등을 운영하고 있습니다. 가끔 흥미를 갖게하는 프로젝트나 의뢰인들을 위해서 프리랜서로 일합니다.</p>
				<p>제가 뭔가 도울일이 있거나 이 문서에 어떤 제안이나 정정할 것이 있다면 <a href="https://alexcabal.com/contact/">연락주세요.</a></p>
				<h3>한국어판 안내</h3>
				<p>이 문서는 2015년 5월 11일에 최종 번역되었습니다. 한국어판에 대한 제안/문의는 <a href="#">Github 저장소</a>에 이슈로 남겨주세요.</p>

				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="introduction">
				<h2>소개</h2>
				<p>PHP는 수년간 비틀리고, 휘어지고, 늘려지고, 난도질 당해온 복잡한 언어입니다. PHP는 매우 일관성이 없고 가끔 결함도 있습니다. 각 버전마다 각각의 독특한 기능과 결점, 특성을 가지고 있어서, 어떤 버전에 어떤 문제가 있는지 계속 확인해나가는 것은 쉽지 않습니다. 종종 그렇듯이 왜 PHP가 그렇게 미움을 받는지 아는 것은 간단합니다.</p>
				<p>그럼에도 불구하고, PHP는 오늘날 웹에서 가장 인기있는 언어입니다. PHP의 긴 역사로 인해서 비밀번호 해싱(hashing)이나 데이터베이스 사용과 같은 기본적인 것을 어떻게 하는지에 관한 많은 자습서(tutorials)를 찾을 수 있습니다. 문제는 5개의 문서를 본다면 무언가를 하기위한 완전히 다른 다섯가지 방법을 발견하게 될 가능성이 높다는 것입니다. 어떤 방법이 "옳은" 방법일까요? 다른 방법들은 잠재적인 버그나 문제(gotchas)가 있는 건가요? 이런 것을 알아내기는 정말 어렵습니다. 여러분은 정답을 알아내기 위해서 인터넷을 찾아볼겁니다.</p>
				<p>이것은 새로운 PHP 프로그래머들이 보기 흉하고, 구식이며, 안전하지 않은 코드때문에 매우 자주 비난당하는 한가지 이유가 됩니다. 하지만 첫번째 구글 검색 결과가 5년된 방법을 가르치는 4년된 문서라면 그들도 어쩔 수 없습니다.</p>
				<p>이 문서는 이런 문제를 해결하고자 합니다. PHP에서 일반적이고 복잡한 문제와 작업을 위한 모범 사례(best practices)로 꼽을 수 있는 기본적인 설명들을 한데 모아보고자 합니다. 저 수준의 작업이 PHP에서 다양하고 복잡한 해결방법들이 있다면, 여기에 해당합니다.</p>
				<h3>이 문서가 포함하는 것</h3>
				<p>이 문서는 PHP 프로그래머가 직면할만한 일반적인 <em>저 수준</em>의 작업이지만, PHP가 많은 선택권을 제공하기 때문에 불명확한 작업을 만났을때 택해야할 가장 바람직한 방법을 제안하는 안내서입니다. 예를 들자면, 데이터베이스 연결하기는 PHP에서 많은 방법이 가능한 일반적인 작업이지만, 그것들 전부가 좋은 방법은 아닙니다. 따라서, 이것은 이 문서에 포함됩니다.</p>
				<p>이 문서는 해결 방법들을 짧게 소개하고 있습니다. 예제는 여러분을 기본적인 설정을 알려주겠지만, 여러분은 나름대로 관련 자료를 찾아서 유용한 것들로 살을 붙여야 합니다.</p>
				<p>이 문서는 최신 PHP를 사용하는 것을 가정합니다. 그래서 여러분이 오래된 버전의 PHP를 사용한다면 이러한 해결 방법들에서 사용하는 어떤 기능들을 사용하지 못할지도 모릅니다.</p>
				<p>이 문서는 살아있는 문서로 PHP가 발전하는 것에 맞춰서 이 문서도 계속 수정하도록 최선을 다할 예정입니다.</p>
				<h3>이 문서가 <em>포함하지 않는 것</em></h3>
				<p>이 문서는 PHP 자습서가 아닙니다. PHP의 기본적인 내용과 문법 등은 다른 곳에서 배우셔야 합니다.</p>
				<p>이 문서는 쿠키 저장이나 캐쉬(caching), 코딩 스타일, 문서화 등과 같은 일반적인 웹 애플리케이션 문제를 위한 안내서가 아닙니다.</p>
				<p>이 문서는 보안 안내서가 아닙니다. 보안 관련 문제를 조금 다루고 있긴 하지만, 여러분의 PHP 애플리케이션을 안전하게 만들기 위해서는 별도로 관련자료를 찾아보셔야 합니다. 특히, 여기에서 제안한 방법을 구현하기 전에 신중하게 검토하십시오. 여러분의 코드는 여러분 자신의 책임입니다.</p>
				<p>이 문서는 특정 코딩 스타일이나 패턴, 프레임워크를 주장하지 않습니다.</p>
				<p>이 문서는 사용자 등록, 로그인 시스템 등과 같은 고 수준 작업을 하기 위한 특정 방법을 옹호하지 않습니다. 이 문서는 철처히 PHP의 긴 역사로 인해서 해결 방법이 복잡하고 불명확할 수 있는 <em>저 수준</em> 작업을 위한 문서입니다.</p>
				<p>이 문서에 소개된 방법이 가장 중요하거나 <em>단 하나의</em> 방법인 것은 아닙니다. 소개된 어떤 방법들은 여러분의 상황에서는 최선이 아닐 수도 있고, 동일한 결과를 얻기위한 다른 많은 방법이 있습니다. 특히 로드가 심한(high-load) 웹 애플리케이션들은 이런 문제에 대한 더 난해한 해결 방법이 도움이 될 수도 있습니다.</p>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="version">
				<h2>어떤 PHP 버전을 사용하나요?</h2>
				<h3>Ubuntu 14.04 LTS에 설치된 PHP 5.5.9-1ubuntu4.2</h3>
				<p>PHP는 웹 세계의 100살 먹은 거북이입니다. 이 거북이의 등껍질에는 풍성하고, 복잡하며, 굴곡진 역사가 새겨져있습니다. 호스팅 환경에서는 여러분이 할 수 있는 것에 제약이 있을 수도 있습니다.</p>
				<p>온전함을 유지하기 위해서 하나의 PHP 버전에 집중할 것입니다. 2013년 4월 30일 기준으로 <strong>PHP 5.5.9-1ubuntu4.2</strong>가 그렇습니다. 이것은 <strong>Ubuntu 14.04 LTS</strong> 서버에서 apt-get을 사용할때 설치되는 버전입니다. 다시 말하면, 많은 사람들이 사용하는 온전한 초기값입니다.</p>
				<p>여기에 소개하는 어떤 해결방법은 다른 버전이나 오래된 버전의 PHP에서 잘 동작하는 것을 발견할지도 모릅니다. 그런 경우, <em>오래된 버전에 숨어있는 버그나 보안 문제들을 확인하는 것은 여러분의 몫입니다.</em></p>
				<aside>
					<h3>Ubuntu 12.04 LTS를 위한 안내</h3>
					<p>Ubuntu 12.04와 Ubuntu 14.04 사이에 PHP 세계에서는 많은 변화가 있었습니다. 12.04를 여전히 흔하게 사용하고 있고, 아래의 몇몇 방법들은 14.04에서 큰 변화가 있기때문에, 이와 같은 박스안에 12.04를 위한 방법을 소개하겠습니다.</p>
					<p>Ubuntu 12.04에서 apt-get으로 설치되는 PHP 버전은 <b>PHP 5.3.10-1ubuntu3.6 with Suhosin-Patch</b>입니다.</p>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="passwords">
				<h2>비밀번호 저장하기</h2>
				<h3>비밀번호를 해시하고 비교할때 내장(built-in) <a href="http://php.net/book.password">비밀번호 해싱</a> 함수를 사용하세요.</h3>
				<p>해싱은 데이터베이스에 저장하기 전에 사용자의 비밀번호를 보호하는 관례적인 방법입니다. md5나 심지어 sha1과 같은 많은 일반적인 해싱 알고리즘은 <a href="http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/">해커들이 쉽게 비밀번호를 알아낼 수 있기 때문에</a> 비밀번호를 저장하기에는 안전하지 않습니다.</p>
				<p>PHP는 현재 비밀번호 해싱을 위한 최고의 알고리즘으로 여기는 bcript 알고리즘을 사용하는 내장(built-in) 비밀번호 해싱 라이브러리를 제공합니다.</p>
				<h4>예제</h4>
				<code class="php">
					&lt;?php
					// 비밀번호를 해시합니다.  $hashedPassword 는 60자 문자열이 됩니다.
					$hashedPassword = password_hash('my super cool password', PASSWORD_DEFAULT);

					// 이제 $hashedPassword 내용을 안전하게 데이터베이스에 저장할 수 있습니다.

					// 사용자가 입력한 것과 해시를 비교하여 올바른 비밀번호를 입력했는지 확인합니다.
					password_verify('the wrong password', $hashedPassword); // false

					password_verify('my super cool password', $hashedPassword); // true
					?&gt;</code>
				<h4>참고</h4>
				<ul>
					<li>많은 사람들이 비밀번호를 해싱하기 전에 salt값을 추가하라고(소금을 치라고) 권장할 것입니다. 그것은 좋은 생각인데, <code>password_hash()</code>는 이미 salt값을 추가해줍니다. 여러분이 직접 salt값을 추가할 필요가 없다는 말입니다.</li>
				</ul>
				<h4>더 읽을거리</h4>
				<ul>
					<li><a href="http://blogs.msdn.com/b/lixiong/archive/2011/12/25/md5-sha1-salt-and-bcrypt.aspx">Why hashing passwords with md5 or sha is unsafe</a></li>
					<li><a href="http://codahale.com/how-to-safely-store-a-password/">How to safely store a password</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)</h3>
					<h3>비밀번호를 해싱하고 비교할때 <a href="http://www.openwall.com/phpass/">phpass</a> 라이브러리를 사용하세요.</h3>
					<p><em><a href="http://www.openwall.com/phpass/">phpass</a> 0.3</em>에서 테스트했습니다.</p>
					<p>12.04에 설치된 PHP 버전에서는 내장 PHP 비밀번호 해싱 라이브러리를 사용할 수 없습니다. 대신, 사용이 쉽고 동일한 bcrypt 기반의 기능을 제공하는 오픈소스 <a href="http://www.openwall.com/phpass/">phpass</a> 라이브러리를 사용하세요.</p>
					<h4>예제</h4>
					<code class="php">
						&lt;?php
						// Include the phpass library
						require_once('phpass-0.3/PasswordHash.php');

						// Initialize the hasher without portable hashes (this is more secure)
						$hasher = new PasswordHash(8, false);

						// Hash the password.  $hashedPassword will be a 60-character string.
						$hashedPassword = $hasher->HashPassword('my super cool password');

						// You can now safely store the contents of $hashedPassword in your database!

						// Check if a user has provided the correct password by comparing what they typed with our hash
						$hasher->CheckPassword('the wrong password', $hashedPassword); // false

						$hasher->CheckPassword('my super cool password', $hashedPassword); // true
						?&gt;</code>
					<h4>더 읽을거리</h4>
					<ul>
						<li><a href="http://www.openwall.com/phpass/">phpass</a></li>
					</ul>
					<h4>참고</h4>
					<ul>
						<li>PHP 새 버전의 <code>password_hash()</code>과 똑같이 phpass도 비밀번호에 salt값을 추가해줍니다.</li>
					</ul>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="mysql">
				<h2>Connecting to and querying a MySQL database</h2>
				<h3>Use <a href="http://php.net/manual/en/book.pdo.php">PDO</a> and its prepared statement functionality.</h3>
				<p>There are many ways to connect to a MySQL database in PHP. <a href="http://php.net/manual/en/book.pdo.php">PDO</a> (PHP Data Objects) is the newest and most robust of them. PDO has a consistent interface across many different types of database, uses an object-oriented approach, and supports more features offered by newer databases.</p>
				<p>You should use PDO's prepared statement functions to help prevent SQL injection attacks. Using the <code><a href="http://php.net/manual/en/pdostatement.bindvalue.php">bindValue()</a></code> function ensures that your SQL is safe from first-order SQL injection attacks. (This isn't 100% foolproof though, see <a href="#pdo-further-reading">Further Reading</a> for more details.) In the past, this had to be achieved with some arcane combination of "magic quote" functions. PDO makes all that gunk unnecessary.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					try{
						// Create a new connection.
						// You'll probably want to replace hostname with localhost in the first parameter.
						// Note how we declare the charset to be utf8mb4.  This alerts the connection that we'll be passing UTF-8 data.  This may not be required depending on your configuration, but it'll save you headaches down the road if you're trying to store Unicode strings in your database.  See "Gotchas".
						// The PDO options we pass do the following:
						// \PDO::ATTR_ERRMODE enables exceptions for errors.  This is optional but can be handy.
						// \PDO::ATTR_PERSISTENT disables persistent connections, which can cause concurrency issues in certain cases.  See "Gotchas".
						$link = new \PDO(	'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4',
											'your-username',
											'your-password',
											array(
												\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
												\PDO::ATTR_PERSISTENT => false
											)
										);

						$handle = $link->prepare('select Username from Users where UserId = ? or Username = ? limit ?');

						// PHP bug: if you don't specify PDO::PARAM_INT, PDO may enclose the argument in quotes.  This can mess up some MySQL queries that don't expect integers to be quoted.
						// See: https://bugs.php.net/bug.php?id=44639
						// If you're not sure whether the value you're passing is an integer, use the is_int() function.
						$handle->bindValue(1, 100, PDO::PARAM_INT);
						$handle->bindValue(2, 'Bilbo Baggins');
						$handle->bindValue(3, 5, PDO::PARAM_INT);

						$handle->execute();

						// Using the fetchAll() method might be too resource-heavy if you're selecting a truly massive amount of rows.
						// If that's the case, you can use the fetch() method and loop through each result row one by one.
						// You can also return arrays and other things instead of objects.  See the PDO documentation for details.
						$result = $handle->fetchAll(\PDO::FETCH_OBJ);

						foreach($result as $row){
							print($row->Username);
						}
					}
					catch(\PDOException $ex){
						print($ex->getMessage());
					}
					?&gt;</code>
				<h4>Gotchas</h4>
				<ul>
					<li>Not passing the <code>PDO::PARAM_INT</code> parameter when binding integer variables can sometimes cause PDO to quote them. This can screw up certain MySQL queries. See <a href="https://bugs.php.net/bug.php?id=44639">this bug report</a>.</li>
					<li>Not having set the character set to utf8mb4 in the connection string might cause Unicode data to be stored incorrectly in your database, depending on your configuration.</li>
					<li>Even if you declare your character set to be utf8mb4, make sure that your actual database tables are in the utf8mb4 character set. For why we use utf8mb4 instead of just utf8, check the <a href="#utf-8">PHP and UTF-8</a> section.</li>
					<li>Enabling persistent connections can possibly lead to weird concurrency-related issues. This isn't a PHP problem, it's an app-level problem. Persistent connections are safe to use as long as you consider the consequences. See <a href="http://stackoverflow.com/questions/3332074/what-are-the-disadvantages-of-using-persistent-connection-in-pdo">this Stack Overflow question</a>.</li>
					<li>You can execute more than one SQL statement in a single <code>execute()</code> call. Just separate the statements with semicolons. <b>Ubuntu 12.04 (PHP &lt;= 5.3.10):</b> If doing this, beware of <a href="https://bugs.php.net/bug.php?id=61207">this bug</a>, which isn't fixed in the version of PHP shipped with Ubuntu 12.04.</li>
				</ul>
				<h4 id="pdo-further-reading">Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/book.pdo.php">PHP Manual: PDO</a></li>
					<li><a href="http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/">Why you should be using PHP's PDO for database access</a></li>
					<li><a href="http://stackoverflow.com/questions/1402017/php-pdo-vs-normal-mysql-connect">Stack Overflow: PHP PDO vs normal mysql_connect</a></li>
					<li><a href="http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection">Stack Overflow: Are PDO prepared statements sufficient to prevent SQL injection?</a></li>
					<li><a href="https://stackoverflow.com/questions/1650591/whether-to-use-set-names">Stack Overflow: Whether to use "SET NAMES"</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="php-tags">
				<h2>PHP tags</h2>
				<h3>Use &lt;?php ?&gt;.</h3>
				<p>There are a few different ways to delimit blocks of PHP: <code>&lt;?php ?&gt;</code>, <code>&lt;?= ?&gt;</code>, <code>&lt;? ?&gt;</code>, and <code>&lt;% %&gt;</code>. While the shorter ones might be more convenient to type, the only one that's guaranteed to work on all PHP servers is <code>&lt;?php ?&gt;</code>. If you ever plan on deploying your PHP to a server whose configuration you can't control, then you should always use <code>&lt;?php ?&gt;</code>.</p>
				<p>If you're only coding for yourself and have control over the PHP configuration you'll be using, you might find the shorter tags to be more convenient. But remember that <code>&lt;? ?&gt;</code> might conflict with XML declarations and <code>&lt;% %&gt;</code> is actually ASP style.</p>
				<p>Whatever you choose, make sure you stay consistent!</p>
				<h4>Gotchas</h4>
				<ul>
					<li>When including a closing <code>?&gt;</code> tag in a pure PHP file (for example, in a file that only contains a class definition), <em>make sure not to leave any trailing newlines after it</em>. While the PHP parser safely "eats" a single newline character after the closing tag, any other newlines might be outputted to the browser and possibly confuse things if you're outputting any HTTP headers later.</li>
					<li>When writing a web app targeting older versions of IE, make sure not to leave a newline between any closing <code>?&gt;</code> tag and the html <code>&lt;!doctype&gt;</code> tag. Old versions of IE will enter <a href="http://www.quirksmode.org/css/quirksmode.html">quirks mode</a> if they encounter any white space, including newlines, before the doctype declaration. This isn't an issue for newer versions of IE and other, more advanced browsers. (Read: every other browser besides IE.)</li>
				</ul>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://stackoverflow.com/questions/200640/are-php-short-tags-acceptable-to-use">Stack Overflow: Are PHP short tags acceptable to use?</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="auto-loading">
				<h2>Auto-loading classes</h2>
				<h3>Use <code><a href="http://php.net/manual/en/function.spl-autoload-register.php">spl_autoload_register()</a></code> to register your auto-load function.</h3>
				<p>PHP provides several ways to auto-load files containing classes that haven't yet been loaded. The older way is to use a magic global function called <code><a href="http://php.net/manual/en/function.autoload.php">__autoload()</a></code>. However you can only have one <code>__autoload()</code> function defined at once, so if you're including a library that <em>also</em> uses the <code>__autoload()</code> function, then you'll have a conflict.</p>
				<p>The correct way to handle this is to name your autoload function something unique, then register it with the <code><a href="http://php.net/manual/en/function.spl-autoload-register.php">spl_autoload_register()</a></code> function. This function allows more than one <code>__autoload()</code> function to be defined, so you won't step on any other code's own <code>__autoload()</code> function.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// First, define your auto-load function.
					function MyAutoload($className){
						include_once($className . '.php');
					}

					// Next, register it with PHP.
					spl_autoload_register('MyAutoload');

					// Try it out!
					// Since we haven't included a file defining the MyClass object, our auto-loader will kick in and include MyClass.php.
					// For this example, assume the MyClass class is defined in the MyClass.php file.
					$var = new MyClass();
					?&gt;</code>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/function.spl-autoload-register.php">PHP Manual: spl_autoload_register()</a></li>
					<li><a href="http://stackoverflow.com/questions/791899/efficient-php-auto-loading-and-naming-strategies">Stack Overflow: Efficient PHP auto-loading and naming strategies</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="quotes">
				<h2>Single vs. double quotes from a performance perspective</h2>
				<h3>It doesn't really matter.</h3>
				<p>A lot of ink has been spilled about whether to define strings with single quotes (') or double quotes ("). Single-quoted strings aren't parsed, so whatever you've put in the string, that's what will show up. Double-quoted strings are parsed and any PHP variables in the string are evaluated. Additionally, escaped characters like \n for newline and \t for tab <i>are not</i> evaluated in single-quoted strings, but <i>are</i> evaluated in double-quoted strings.</p>
				<p>Because double-quoted strings are evaluated at run time, the theory is that using single-quoted strings will improve performance because PHP won't have to evaluate every single string. While this might be true on a certain scale, for the average real-life application the difference is so small that it doesn't really matter. So for an average app, it doesn't matter what you choose. For <em>extremely</em> high-load apps, it might matter a little. Make a choice depending on what your app needs, but whatever you choose, be consistent.</p>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/language.types.string.php">PHP Manual: Strings</a></li>
					<li><a href="http://phpbench.com/">The PHP Benchmark</a> (Scroll down to Quote Types)</li>
					<li><a href="http://stackoverflow.com/questions/482202/is-there-a-performance-benefit-single-quote-vs-double-quote-in-php">Stack Overflow: Is there a performance benefit to single quotes vs double quotes in PHP?</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="constants">
				<h2><code>define()</code> vs. <code>const</code></h2>
				<h3>Use <code><a href="http://www.php.net/manual/en/function.define.php">define()</a></code> unless readability, class constants, or micro-optimization are concerns.</h3>
				<p>Traditionally in PHP you would define constants using the <code><a href="http://www.php.net/manual/en/function.define.php">define()</a></code> function. But at some point PHP gained the ability to also declare constants with the <code><a href="http://php.net/manual/en/language.oop5.constants.php">const</a></code> keyword. Which one should you use when defining your constants?</p>
				<p>The answer lies in the little differences between the two methods.</p>
				<ol>
					<li><code>define()</code> defines constants at run time, while <code>const</code> defines constants at compile time. This gives <code>const</code> a very slight speed edge, but not one worth worrying about unless you're building large-scale software.</li>
					<li><code>define()</code> puts constants in the global scope, although you can include namespaces in your constant name. That means you can't use <code>define()</code> to define class constants.</li>
					<li><code>define()</code> lets you use expressions both in the constant name and in the constant value, unlike <code>const</code> which allows neither. This makes <code>define()</code> much more flexible.</li>
					<li><code>define()</code> can be called within an <code>if()</code> block, while <code>const</code> cannot.</li>
				</ol>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Let's see how the two methods treat namespaces
					namespace MiddleEarth\Creatures\Dwarves;
					const GIMLI_ID = 1;
					define('MiddleEarth\Creatures\Elves\LEGOLAS_ID', 2);

					echo(\MiddleEarth\Creatures\Dwarves\GIMLI_ID);	// 1
					echo(\MiddleEarth\Creatures\Elves\LEGOLAS_ID);	// 2; note that we used define(), but the namespace is still recognized

					// Now let's declare some bit-shifted constants representing ways to enter Mordor.
					define('TRANSPORT_METHOD_SNEAKING', 1 &lt;&lt; 0); // OK!
					const TRANSPORT_METHOD_WALKING = 1 &lt;&lt; 1; // Compile error! const can't use expressions as values

					// Next, conditional constants.
					define('HOBBITS_FRODO_ID', 1);

					if($isGoingToMordor){
						define('TRANSPORT_METHOD', TRANSPORT_METHOD_SNEAKING); // OK!
						const PARTY_LEADER_ID = HOBBITS_FRODO_ID // Compile error: const can't be used in an if block
					}

					// Finally, class constants
					class OneRing{
						const MELTING_POINT_CELSIUS = 1000000; // OK!
						define('MELTING_POINT_ELVISH_DEGREES', 200); // Compile error: can't use define() within a class
					}
					?&gt;</code>
				<p>Because <code>define()</code> is ultimately more flexible, it's the one you should use to avoid headaches unless you specifically require class constants. Using <code>const</code> generally results in more readable code, but at the expense of flexibility.</p>
				<p>Whichever one you use, be consistent!</p>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://stackoverflow.com/questions/2447791/define-vs-const">Stack Overflow: define() vs const</a></li>
					<li><a href="http://www.php.net/manual/en/language.constants.syntax.php">PHP Manual: Constants</a></li>
					<li><a href="http://stackoverflow.com/questions/1225082/define-vs-variable-in-php">Stack Overflow: define() vs variable</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="opcode-cache">
				<h2>Caching PHP opcode</h2>
				<h3>Lucky you: PHP has a built-in opcode cache!</h3>
				<p>In older versions of PHP, every time a script was executed it would have to be compiled from scratch, even if it had been compiled before. Opcode caches were additional software that saved previously compiled versions of PHP, speeding things up a bit. There were various flavors of caches you could choose from.</p>
				<p>Lucky for us, the version of PHP that ships with Ubuntu 14.04 <em>includes a built-in opcode cache</em> that's turned on by default. So there's nothing for you to do!</p>
				<p>For posterity, below are instructions for using an opcode cache in Ubuntu 12.04, which doesn't include its own.</p>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://www.php.net/manual/en/book.opcache.php">PHP Manual: Opcache</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)</h3>
					<h3>Use <a href="http://php.net/manual/en/book.apc.php">APC</a> as an opcode cache.</h3>
					<p>There are several PHP opcode caches available, notably <a href="http://sourceforge.net/projects/eaccelerator/">eaccelerator</a>, <a href="http://xcache.lighttpd.net/">xcache</a>, and <a href="http://php.net/manual/en/book.apc.php">APC</a>. APC is officially supported by the PHP project, is the most active, and is the easiest to install. It also provides an optional <a href="http://memcached.org/">memcached</a>-like persistent key-value store. For these reasons, it's the one you should be using.</p>
					<h4>Installing APC</h4>
					<p>You can install APC on Ubuntu 12.04 by running this command in your terminal:</p>
					<code class="terminal">sudo apt-get install php-apc</code>
					<p>No further configuration is necessary.</p>
					<h4>Gotchas</h4>
					<ul>
						<li>If you're not using <a href="#serving-php">PHP-FPM</a> (for example you're using <a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a> or <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a>), each PHP process will have its unique APC instance, including key-value store. This can lead to synchronization problems in your app code if you're not careful.</li>
					</ul>
					<h4>Further reading</h4>
					<ul>
						<li><a href="http://php.net/manual/en/book.apc.php">PHP Manual: APC</a></li>
					</ul>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="memcached">
				<h2>PHP and Memcached</h2>
				<h3>If you need a distributed cache, use the <a href="http://php.net/manual/en/book.memcached.php">Memcached</a> client library.  Otherwise, use <a href="http://pecl.php.net/package/APCu">APCu</a>.</h3>
				<p>A caching system can often improve your app's performance. <a href="http://memcached.org/">Memcached</a> is a popular choice and it works with many languages, including PHP.</p>
				<p>However, when it comes to accessing a Memcached server from a PHP script, you have two different and very stupidly named choices of client library: <a href="http://php.net/manual/en/book.memcache.php">Memcache</a> and <a href="http://php.net/manual/en/book.memcached.php">Memcached</a>. They're different libraries with almost the same name, and both are used to access a Memcached instance.</p>
				<p>It turns out that the Memcache<u>d</u> library is the one that best implements the Memcached protocol. It includes a few useful features that the Memcache library doesn't, and seems to be the one most actively developed.</p>
				<p>However if you don't need to access a Memcached instance from a series of distributed servers, then <a href="http://pecl.php.net/package/APCu">use APCu instead</a>. APCu is supported by the PHP project and has much of the same functionality as Memcached.</p>
				<h4>Installing the Memached client library</h4>
				<p>After you install the Memcached server, you need to install the Memcached client library. Without the library, your PHP scripts won't be able to communicate with the Memcached server.</p>
				<p>You can install the Memcached client library on Ubuntu 14.04 by running this command in your terminal:</p>
				<code class="terminal">sudo apt-get install php5-memcached</code>
				<h4>Using APCu instead</h4>
				<p>Before Ubuntu 14.04, the APC project was both an opcode cache <em>and</em> a Memcached-like key-value store. Since the version of PHP that ships with 14.04 <a href="#opcode-cache">now includes a built-in opcode cache</a>, APC was split into the APCu project, which is essentially APC's key-value storage functionality&mdash;AKA the "user cache", or the "u" in APCu&mdash;without the opcode-cache parts.</p>
				<h4>Installing APCu</h4>
				<p>You can install APCu on Ubuntu 14.04 by running this command in your terminal:</p>
				<code class="terminal">sudo apt-get install php5-apcu</code>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Store some values in the APCu cache.  We can optionally pass a time-to-live, but in this example the values will live forever until they're garbage-collected by APCu.
					apc_store('username-1532', 'Frodo Baggins');
					apc_store('username-958', 'Aragorn');
					apc_store('username-6389', 'Gandalf');

					// After storing these values, any PHP script can access them, no matter when it's run!
					$value = apc_fetch('username-958', $success);
					if($success === true)
						print($value); // Aragorn

					$value = apc_fetch('username-1', $success); // $success will be set to boolean false, because this key doesn't exist.
					if($success !== true) // Note the !==, this checks for true boolean false, not "falsey" values like 0 or empty string.
						print('Key not found');

					apc_delete('username-958'); // This key will no longer be available.
					?&gt;</code>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/book.memcached.php">PHP Manual: Memcached</a></li>
					<li><a href="http://pecl.php.net/package/APCu">PECL: APCu</a></li>
					<li><a href="http://stackoverflow.com/questions/1442411/using-memcache-vs-memcached-with-php">Stack Overflow: Using Memcache vs Memcached with PHP</a></li>
					<li><a href="http://stackoverflow.com/questions/815041/memcached-vs-apc-which-one-should-i-choose">Stack Overflow: Memcached vs APC, which one should I choose?</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)</h3>
					<h3>Using <a href="http://php.net/manual/en/book.apc.php">APC</a> instead of Memcached</h3>
					<p>If you're using APC as both a key-value store and an opcode cache in Ubuntu 12.04, then the example above will also work&mdash;APC and APCu have an identical API.</p>
					<p>See the <a href="#opcode-cache">section on opcode caching</a> for instructions on how to install APC on Ubuntu 12.04.</p>
					<h4>Further reading</h4>
					<ul>
						<li><a href="http://php.net/manual/en/book.apc.php">PHP Manual: APC</a></li>
					</ul>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="regex">
				<h2>PHP and regex</h2>
				<h3>Use the <a href="http://php.net/manual/en/book.pcre.php">PCRE</a> (<code>preg_*</code>) family of functions.</h3>
				<p>PHP has two different ways of using regular expressions: the <a href="http://php.net/manual/en/book.pcre.php">PCRE</a> (Perl-compatible, <code>preg_*</code>) functions and the <a href="http://php.net/manual/en/book.regex.php">POSIX</a> (POSIX extended, <code>ereg_*</code>) functions.</p>
				<p>Each family of functions uses a slightly different flavor of regular expression. Luckily for us, the POSIX functions have been deprecated since PHP 5.3.0. Because of this, you should never write new code using the POSIX functions. Always use the PCRE functions, which are the <code>preg_*</code> functions.</p>
				<h4>Further Reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/book.pcre.php">PHP Manual: PCRE</a></li>
					<li><a href="http://www.noupe.com/php/php-regular-expressions.html">Getting started with PHP regular expressions</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="serving-php">
				<h2>Serving PHP from a web server</h2>
				<h3>Use <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>.</h3>
				<p>There are several ways of configuring a web server to serve PHP. The traditional (and terrible) way is to use Apache's <a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a>. Mod_php attaches PHP to Apache itself, but Apache does a very bad job of managing it. You'll suffer from severe memory problems as soon as you get any kind of real traffic.</p>
				<p>Two new options soon became popular: <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a> and <a href="http://httpd.apache.org/mod_fcgid/">mod_fcgid</a>. Both of these keep a limited number of PHP processes running, and Apache sends requests to these interfaces to handle PHP execution on its behalf. Because these libraries limit how many PHP processes are alive, memory usage is greatly reduced without affecting performance.</p>
				<p>Some smart people created an implementation of fastcgi that was specially designed to work really well with PHP, and they called it <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>. This was the standard solution for web servers since 12.04.</p>
				<p>In the years since Ubuntu 12.04, Apache introduced a new method of interacting with PHP-FPM: <a href="http://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a>. Unfortunately, the version of Apache that ships with Ubuntu 14.04 has a few problems with this module, including not being able to use socket-based connections, issues with mod_rewrite, and issues with 404 and similar pages. Because of these problems you should stick with the tried-and-true method of working with PHP-FPM that we used in Ubuntu 12.04.</p>
				<p>The following example is for Apache 2.4.7, but PHP-FPM also works for other web servers like Nginx.</p>
				<h4>Installing PHP-FPM and Apache</h4>
				<p>You can install PHP-FPM and Apache on Ubuntu 14.04 by running these command in your terminal:</p>
				<code class="terminal multiline">
						<span>sudo apt-get install apache2-mpm-event libapache2-mod-fastcgi php5-fpm</span>
						<span>sudo a2enmod actions alias fastcgi</span>
					</code>
				<p>Note that we <em>must</em> use apache2-mpm-event (or apache2-mpm-worker), <em>not</em> apache2-mpm-prefork or apache2-mpm-threaded.</p>
				<p>Next, we'll configure our Apache virtualhost to route PHP requests to the PHP-FPM process. Place the following in your Apache configuration file (in Ubuntu 14.04 the default one is /etc/apache2/sites-available/000-default.conf).</p>
				<code class="php">
					&lt;Directory /&gt;
						Require all granted
					&lt;/Directory&gt;
					&lt;VirtualHost *:80&gt;
						Action php5-fcgi /php5-fcgi
						Alias /php5-fcgi /usr/lib/cgi-bin/php5-fcgi
						FastCgiExternalServer /usr/lib/cgi-bin/php5-fcgi -socket /var/run/php5-fpm.sock -idle-timeout 120 -pass-header Authorization
						&lt;FilesMatch "\.php$"&gt;
							SetHandler	php5-fcgi
						&lt;/FilesMatch&gt;
					&lt;/VirtualHost&gt;</code>
				<p>Finally, restart Apache and the FPM process:</p>
				<code class="terminal">sudo service apache2 restart && sudo service php5-fpm restart</code>
				<h4>Gotchas</h4>
				<ul>
					<li>Using the <code><a href="http://httpd.apache.org/docs/2.4/mod/mod_mime.html#addhandler">AddHandler</a></code> directive instead of the <code><a href="http://httpd.apache.org/docs/2.4/mod/core.html#sethandler">SetHandler</a></code> directive can be a security risk. <code>AddHandler</code> will execute PHP in files that have ".php" <em>anywhere in the file name</em>. So if a user uploads evil.php.gif using your file upload form, you might be in for a nasty surprise.</li>
				</ul>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/install.fpm.php">PHP Manual: PHP-FPM</a></li>
					<li><a href="http://php-fpm.org">PHP-FPM homepage</a></li>
					<li><a href="https://alexcabal.com/installing-apache-mod_fastcgi-php-fpm-on-ubuntu-server-maverick/">Installing Apache + mod_fastcgi + PHP-FPM on Ubuntu Server Maverick</a></li>
					<li><a href="http://www.joomlaperformance.com/articles/webcasts/why_mod_php_is_bad_for_performance_52_58.html">Why mod_php is bad for performance</a></li>
				</ul>
				<aside>
					<h3>Ubuntu 12.04 (Apache 2.2.22)</h3>
					<p>The configuration for Ubuntu 12.04 is just as above, except don't include the <code>&lt;Directory&gt;</code> block in the configuration file.</p>
					<p>The default site in Apache 2.2.22 is located at /etc/apache2/sites-available/default.</p>
					<p>Apache 2.2.22 doesn't have a stable event MPM, so install apache2-mpm-worker instead of apache2-mpm-event.</p>
				</aside>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="email">
				<h2>Sending email</h2>
				<h3>Use <a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a>.</h3>
				<p><em>Tested with <a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a> 5.2.7.</em></p>
				<p>PHP provides a <code><a href="http://php.net/manual/en/function.mail.php">mail()</a></code> function that looks enticingly simple and easy. Unfortunately, like a lot of things in PHP, its simplicity is deceptive and using it at face value can lead to serious security problems.</p>
				<p>Email is a set of protocols with an even more tortured history than PHP. Suffice it to say that there are so many gotchas in sending email that just being in the same room as PHP's <code>mail()</code> function should give you the shivers.</p>
				<p><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a> is a popular and well-aged open-source library that provides an easy interface for sending mail securely. It takes care of the gotchas for you so you can concentrate on more important things.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Include the PHPMailer library
					require_once('phpmailer-5.2.7/PHPMailerAutoload.php');

					// Passing 'true' enables exceptions.  This is optional and defaults to false.
					$mailer = new PHPMailer(true);

					// Send a mail from Bilbo Baggins to Gandalf the Grey

					// Set up to, from, and the message body.  The body doesn't have to be HTML; check the PHPMailer documentation for details.
					$mailer->Sender = 'bbaggins@example.com';
					$mailer->AddReplyTo('bbaggins@example.com', 'Bilbo Baggins');
					$mailer->SetFrom('bbaggins@example.com', 'Bilbo Baggins');
					$mailer->AddAddress('gandalf@example.com');
					$mailer->Subject = 'The finest weed in the South Farthing';
					$mailer->MsgHTML('&lt;p&gt;You really must try it, Gandalf!&lt;/p&gt;&lt;p&gt;-Bilbo&lt;/p&gt;');

					// Set up our connection information.
					$mailer->IsSMTP();
					$mailer->SMTPAuth = true;
					$mailer->SMTPSecure = 'ssl';
					$mailer->Port = 465;
					$mailer->Host = 'my smtp host';
					$mailer->Username = 'my smtp username';
					$mailer->Password = 'my smtp password';

					// All done!
					$mailer->Send();
					?&gt;</code>
				<h4>Further reading</h4>
				<ul>
					<li><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer at Github</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="validating-emails">
				<h2>Validating email addresses</h2>
				<h3>Use the <code><a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a></code> function.</h3>
				<p>A common task your web app might need to do is to check if a user has entered a valid email address. You'll no doubt find online a dizzying range of complex regular expressions that all claim to solve this problem, but the easiest way is to use PHP's built-in <code><a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a></code> function, which can validate email addresses.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					filter_var('sgamgee@example.com', FILTER_VALIDATE_EMAIL); // Returns "sgamgee@example.com". This is a valid email address.
					filter_var('sauron@mordor', FILTER_VALIDATE_EMAIL); // Returns boolean false! This is *not* a valid email address.
					?&gt;</code>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/function.filter-var.php">PHP Manual: filter_var()</a></li>
					<li><a href="http://php.net/manual/en/filter.filters.php">PHP Manual: Types of filters</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="sanitizing-html">
				<h2>Sanitizing HTML input and output</h2>
				<h3>Use the <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> function for simple sanitization and the <a href="http://htmlpurifier.org/">HTML Purifier</a> library for complex sanitization.</h3>
				<p><em>Tested with <a href="http://htmlpurifier.org/">HTML Purifier</a> 4.6.0.</em></p>
				<p>When displaying user input in any web application, it's essential to "sanitize" it first to remove any potentially dangerous HTML. A malicious user can craft HTML that, if outputted directly by your web app, can be dangerous to the person viewing it.</p>
				<p>While it may be tempting to use regular expressions to sanitize HTML, <em>do not do this</em>. HTML is a complex language and it's virtually guaranteed that any attempt you make at using regular expressions to sanitize HTML will fail.</p>
				<p>You might also find advice suggesting you use the <code><a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a></code> function. While <code>strip_tags()</code> is technically safe to use, it's a "dumb" function in the sense that if the input is invalid HTML (say, is missing an ending tag), then strip_tags() might remove much more content than you expected. As such it's not a great choice either, because non-technical users often use the &lt; and &gt; characters in communications.</p>
				<p>If you read the section on <a href="#validating-emails">validating email addresses</a>, you might also be considering using the <code><a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a></code> function. However <a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">the <code>filter_var()</code> function has problems with line breaks</a>, and requires non-intuitive configuration to closely mirror the <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> function. As such it's not a good choice either.</p>
				<h4>Sanitization for simple requirements</h4>
				<p>If your web app only needs to completely escape (and thus render harmless, but not remove entirely) HTML, use PHP's built-in <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> function. This function is much faster than HTML Purifier, because it doesn't perform any validation on the HTML&mdash;it just escapes everything.</p>
				<p><code>htmlentities()</code> differs from its cousin <code><a href="http://php.net/manual/en/function.htmlspecialchars.php">htmlspecialchars()</a></code> in that it encodes <em>all</em> applicable HTML entities, not just a small subset.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
					$evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';

					// Use the ENT_QUOTES flag to make sure both single and double quotes are escaped.
					// Use the UTF-8 character encoding if you've stored the text as UTF-8 (as you should have).
					// See the UTF-8 section in this document for more details.
					$safeHtml = htmlentities($evilHtml, ENT_QUOTES, 'UTF-8'); // $safeHtml is now fully escaped HTML.  You can output $safeHtml to your users without fear!
					?&gt;</code>
				<h4>Sanitization for complex requirements</h4>
				<p>For many web apps, simply escaping HTML isn't enough. You probably want to entirely remove any HTML, or allow a small subset of HTML through. To do this, use the <a href="http://htmlpurifier.org/">HTML Purifier</a> library.</p>
				<p>HTML Purifier is a well-tested but slow library. That's why you should use <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> if your requirements aren't that complex, because it will be much, much faster.</p>
				<p>HTML Purifier has the advantage over <code><a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a></code> because it validates the HTML before sanitizing it. That means if the user has inputted invalid HTML, HTML Purifier has a better chance of preserving the intended meaning of the HTML than <code>strip_tags()</code> does. It's also highly customizable, allowing you to whitelist a subset of HTML to keep in the output.</p>
				<p>The downside is that it's quite slow, it requires some setup that might not be feasible in a shared hosting environment, and the documentation is often complex and unclear. The following example is a basic configuration; check the <a href="http://htmlpurifier.org/docs">documentation</a> to read about the more advanced features HTML Purifier offers.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Include the HTML Purifier library
					require_once('htmlpurifier-4.6.0/HTMLPurifier.auto.php');

					// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
					$evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';

					// Set up the HTML Purifier object with the default configuration.
					$purifier = new HTMLPurifier(HTMLPurifier_Config::createDefault());

					$safeHtml = $purifier->purify($evilHtml); // $safeHtml is now sanitized.  You can output $safeHtml to your users without fear!
					?&gt;</code>
				<h4>Gotchas</h4>
				<ul>
					<li>Using <code>htmlentities()</code> with the wrong character encoding can result in surprising output. Always make sure that you specify a character encoding when calling the function, and that it matches the encoding of the string being sanitized. See the <a href="#utf-8">UTF-8 section</a> for more details.</li>
					<li>Always include the <code>ENT_QUOTES</code> and character encoding parameters when using <code>htmlentities()</code>. By default, <code>htmlentities()</code> doesn't encode single quotes. What a dumb default!</li>
					<li>HTML Purifier is extremely slow for complex HTML. Consider setting up a caching solution like <a href="#opcode-cache">APC</a> to store the sanitized result for later use.</li>
				</ul>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://htmlpurifier.org/comparison">Comparison between PHP HTML sanitizers</a></li>
					<li><a href="http://stackoverflow.com/questions/3605629/php-prevent-xss-with-strip-tags">Stack Overflow: Prevent XSS with strip_tags()?</a></li>
					<li><a href="http://stackoverflow.com/questions/129677/whats-the-best-method-for-sanitizing-user-input-with-php">Stack Overflow: What's the best method for sanitizing user input with PHP?</a></li>
					<li><a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">Stack Overflow: FILTER_SANITIZE_SPECIAL_CHARS problem with line breaks</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="utf-8">
				<h2>PHP and UTF-8</h2>
				<h3>There's no one-liner.  Be careful, detailed, and consistent.</h3>
				<p>UTF-8 in PHP sucks. Sorry.</p>
				<p>Right now PHP does not support Unicode at a low level. There are ways to ensure that UTF-8 strings are processed OK, but it's not easy, and it requires digging in to almost all levels of the web app, from HTML to SQL to PHP. We'll aim for a brief, practical summary.</p>
				<h4>UTF-8 at the PHP level</h4>
				<p>The basic <a href="http://php.net/manual/en/language.operators.string.php">string operations</a>, like concatenating two strings and assigning strings to variables, don't need anything special for UTF-8. However most <a href="http://php.net/manual/en/ref.strings.php">string functions</a>, like <code><a href="http://php.net/manual/en/function.strpos.php">strpos()</a></code> and <code><a href="http://php.net/manual/en/function.strlen.php">strlen()</a></code>, <em>do</em> need special consideration. These functions often have an <code>mb_*</code> counterpart: for example, <code><a href="http://php.net/manual/en/function.mb-strpos.php">mb_strpos()</a></code> and <code><a href="http://php.net/manual/en/function.mb-strlen.php">mb_strlen()</a></code>. Together, these counterpart functions are called the <a href="http://php.net/manual/en/ref.mbstring.php">Multibyte String Functions</a>. The multibyte string functions are specifically designed to operate on Unicode strings.</p>
				<p>You <em>must</em> use the <code>mb_*</code> functions whenever you operate on a Unicode string. For example, if you use <code><a href="http://php.net/manual/en/function.substr.php">substr()</a></code> on a UTF-8 string, there's a good chance the result will include some garbled half-characters. The correct function to use would be the multibyte counterpart, <code><a href="http://php.net/manual/en/function.mb-substr.php">mb_substr()</a></code>.</p>
				<p>The hard part is remembering to use the <code>mb_*</code> functions <em>at all times</em>. If you forget even just once, your Unicode string has a chance of being garbled during further processing.</p>
				<p>Not all string functions have an <code>mb_*</code> counterpart. If there isn't one for what you want to do, then you might be out of luck.</p>
				<p>Additionally, you should use the <code><a href="http://php.net/manual/en/function.mb-internal-encoding.php">mb_internal_encoding()</a></code> function at the top of every PHP script you write (or at the top of your global include script), and the <code><a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a></code> function right after it if your script is outputting to a browser. Explicitly defining the encoding of your strings in every script will save you a lot of headaches down the road.</p>
				<p>Finally, many PHP functions that operate on strings have an optional parameter letting you specify the character encoding. You should always explicitly indicate UTF-8 when given the option. For example, <code><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a></code> has an option for character encoding, and you should <em>always</em> specify UTF-8 if dealing with such strings.</p>
				<h4>UTF-8 at the MySQL level</h4>
				<p>If your PHP script accesses MySQL, there's a chance your strings could be stored as non-UTF-8 strings in the database even if you follow all of the precautions above.</p>
				<p>To make sure your strings go from PHP to MySQL as UTF-8, make sure your database and tables are all set to the utf8mb4 character set and collation, and that you use the utf8mb4 character set in the PDO connection string. For an example, see the section on <a href="#mysql">connecting to and querying a MySQL database</a>. This is <em>critically important</em>.</p>
				<p>Note that you must use the utf8mb4 character set for complete UTF-8 support, <em>not</em> the utf8 character set! See <a href="#utf8-further-reading">Further Reading</a> for why.</p>
				<h4>UTF-8 at the browser level</h4>
				<p>Use the <code><a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a></code> function to ensure that your PHP script outputs UTF-8 strings to your browser. In your HTML, include the <code><a href="http://htmlpurifier.org/docs/enduser-utf8.html">charset</a></code> meta tag in your page's <code>&lt;head&gt;</code> tag.
					<h4>Example</h4>
					<code class="php">
					&lt;?php
					// Tell PHP that we're using UTF-8 strings until the end of the script
					mb_internal_encoding('UTF-8');

					// Tell PHP that we'll be outputting UTF-8 to the browser
					mb_http_output('UTF-8');

					// Our UTF-8 test string
					$string = 'Êl síla erin lû e-govaned vîn.';

					// Transform the string in some way with a multibyte function
					// Note how we cut the string at a non-Ascii character for demonstration purposes
					$string = mb_substr($string, 0, 15);

					// Connect to a database to store the transformed string
					// See the PDO example in this document for more information
					// Note that we define the character set as utf8mb4 in the PDO connection string
					$link = new \PDO(	'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4',
										'your-username',
			 							'your-password',
										array(
											\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
											\PDO::ATTR_PERSISTENT => false
										)
									);

					// Store our transformed string as UTF-8 in our database
					// Your DB and tables are in the utf8mb4 character set and collation, right?
					$handle = $link->prepare('insert into ElvishSentences (Id, Body) values (?, ?)');
					$handle->bindValue(1, 1, PDO::PARAM_INT);
					$handle->bindValue(2, $string);
					$handle->execute();

					// Retrieve the string we just stored to prove it was stored correctly
					$handle = $link->prepare('select * from ElvishSentences where Id = ?');
					$handle->bindValue(1, 1, PDO::PARAM_INT);
					$handle->execute();

					// Store the result into an object that we'll output later in our HTML
					$result = $handle->fetchAll(\PDO::FETCH_OBJ);
					?&gt;&lt;!doctype html&gt;
					&lt;html&gt;
						&lt;head&gt;
							&lt;meta charset="UTF-8" /&gt;
							&lt;title&gt;UTF-8 test page&lt;/title&gt;
						&lt;/head&gt;
						&lt;body&gt;
							&lt;?php
							foreach($result as $row){
								print($row->Body);  // This should correctly output our transformed UTF-8 string to the browser
							}
							?&gt;
						&lt;/body&gt;
					&lt;/html&gt;</code>
					<h4 id="utf8-further-reading">Further reading</h4>
					<ul>
						<li><a href="http://php.net/manual/en/ref.mbstring.php">PHP Manual: Multibyte String Functions</a></li>
						<li><a href="http://blog.loftdigital.com/blog/php-utf-8-cheatsheet">PHP UTF-8 Cheatsheet</a></li>
						<li><a href="http://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible">Stack Overflow: What factors make PHP Unicode-incompatible?</a></li>
						<li><a href="http://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings">Stack Overflow: Best practices in PHP and MySQL with international strings</a></li>
						<li><a href="http://mathiasbynens.be/notes/mysql-utf8mb4">How to support full Unicode in MySQL databases</a></li>
					</ul>
					<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="working-with-dates-and-times">
				<h2>Working with dates and times</h2>
				<h3>Use the <a href="http://www.php.net/manual/en/class.datetime.php"><code>DateTime</code> class</a>.</h3>
				<p>In the bad old days of PHP we had to work with dates and times using a bewildering combination of <code><a href="http://www.php.net/manual/en/function.date.php">date()</a></code>, <code><a href="http://www.php.net/manual/en/function.gmdate.php">gmdate()</a></code>, <code><a href="http://www.php.net/manual/en/function.date-timezone-set.php">date_timezone_set()</a></code>, <code><a href="http://www.php.net/manual/en/function.strtotime.php">strtotime()</a></code>, and so on. Sadly you'll still find lots of tutorials online featuring these difficult and old-fashioned functions.</p>
				<p>Fortunately for us, the version of PHP we're talking about features the much friendlier <a href="http://www.php.net/manual/en/class.datetime.php"><code>DateTime</code> class</a>. This class encapsulates all the functionality <em>and more</em> of the old date functions in one easy-to-use class, with the bonus of making time zone conversions much simpler. Always use the <code>DateTime</code> class for creating, comparing, changing, and displaying dates in PHP.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					// Construct a new UTC date.  Always specify UTC unless you really know what you're doing!
					$date = new DateTime('2011-05-04 05:00:00', new DateTimeZone('UTC'));

					// Add ten days to our initial date
					$date->add(new DateInterval('P10D'));

					echo($date->format('Y-m-d h:i:s')); // 2011-05-14 05:00:00

					// Sadly we don't have a Middle Earth timezone
					// Convert our UTC date to the PST (or PDT, depending) time zone
					$date->setTimezone(new DateTimeZone('America/Los_Angeles'));

					// Note that if you run this line yourself, it might differ by an hour depending on daylight savings
					echo($date->format('Y-m-d h:i:s')); // 2011-05-13 10:00:00

					$later = new DateTime('2012-05-20', new DateTimeZone('UTC'));

					// Compare two dates
					if($date &lt; $later)
						echo('Yup, you can compare dates using these easy operators!');

					// Find the difference between two dates
					$difference = $date->diff($later);

					echo('The 2nd date is ' . $difference['days'] . ' later than 1st date.');
					?&gt;
					</code>
				<h4>Gotchas</h4>
				<ul>
					<li>
						<p>If you don't specify a time zone, <code><a href="http://www.php.net/manual/en/datetime.construct.php">DateTime::__construct()</a></code> will set the resulting date's time zone to <em>the time zone of the computer you're running on</em>. This can lead to spectacular headaches later on. <strong>Always specify the UTC time zone when creating new dates unless you really know what you're doing.</strong></p>
					</li>
					<li>
						<p>If you use a Unix timestamp in <code>DateTime::__construct()</code>, the time zone will always be set to UTC regardless of what you specify in the second argument.</p>
					</li>
					<li>
						<p>Passing zeroed dates (e.g. &quot;0000-00-00&quot;, a value commonly produced by MySQL as the default value in a DateTime column) to <code>DateTime::__construct()</code> will result in a nonsensical date, not &quot;0000-00-00&quot;.</p>
					</li>
					<li>
						<p>Using <code><a href="http://www.php.net/manual/en/datetime.gettimestamp.php">DateTime::getTimestamp()</a></code> on 32-bit systems will not represent dates past 2038. 64-bit systems are OK.</p>
					</li>
				</ul>
				<h4>Further Reading</h4>
				<ul>
					<li>
						<p><a href="http://www.php.net/manual/en/book.datetime.php">PHP Manual: The DateTime class</a></p>
					</li>
					<li>
						<p><a href="http://stackoverflow.com/questions/5319710/accessing-dates-in-php-beyond-2038">Stack Overflow: Accessing dates beyond 2038</a></p>
					</li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="checking-for-null">
				<h2>Checking if a value is null or false</h2>
				<h3>Use the <code><a href="http://php.net/manual/en/language.operators.comparison.php">===</a></code> operator to check for null and boolean false values.</h3>
				<p>PHP's loose typing system offers many different ways of checking a variable's value. However it also presents a lot of problems. Using <code><a href="http://php.net/manual/en/language.operators.comparison.php">==</a></code> to check if a value is null or false can return false positives if the value is actually an empty string or 0. <code><a href="http://php.net/manual/en/function.isset.php">isset()</a></code> checks whether a variable has a value, <em>not</em> whether that value is null or false, so it's not appropriate to use here.</p>
				<p>The <code><a href="http://php.net/manual/en/function.is-null.php">is_null()</a></code> function accurately checks if a value is null, and the <code><a href="http://php.net/manual/en/function.is-bool.php">is_bool()</a></code> function checks if it's a boolean value (like <code>false</code>), but there's an even better option: the <code><a href="http://php.net/manual/en/language.operators.comparison.php">===</a></code> operator. <code>===</code> checks if the values are <em>identical</em>, which is not the same as <em>equivalent</em> in PHP's loosely-typed world. It's also slightly faster than <code>is_null()</code> and <code>is_bool()</code>, and looks nicer than using a function for comparison.</p>
				<h4>Example</h4>
				<code class="php">
					&lt;?php
					$x = 0;
					$y = null;

					// Is $x null?
					if($x == null)
						print('Oops! $x is 0, not null!');

					// Is $y null?
					if(is_null($y))
						print('Great, but could be faster.');

					if($y === null)
						print('Perfect!');

					// Does the string abc contain the character a?
					if(strpos('abc', 'a'))
						// GOTCHA!  strpos returns 0, indicating it wishes to return the position of the first character.
						// But PHP interpretes 0 as false, so we never reach this print statement!
						print('Found it!');

					//Solution: use !== (the opposite of ===) to see if strpos() returns 0, or boolean false.
					if(strpos('abc', 'a') !== false)
						print('Found it for real this time!');
					?&gt;</code>
				<h4>Gotchas</h4>
				<ul>
					<li>When testing the return value of a function that can return either 0 or boolean <code>false</code>, like <code>strpos()</code>, always use <code>===</code> and <code>!==</code>, or you'll run in to problems.</li>
				</ul>
				<h4>Further reading</h4>
				<ul>
					<li><a href="http://php.net/manual/en/language.operators.comparison.php">PHP Manual: Comparison operators</a></li>
					<li><a href="http://stackoverflow.com/questions/8228837/is-nullx-vs-x-null-in-php">Stack Overflow: is_null() vs ===</a></li>
				</ul>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
			<section id="suggestions">
				<h2>Suggestions and corrections</h2>
				<p>Thanks for reading! If you haven't figured it out already, PHP is complex and filled with pitfalls. Since I'm only human, there might be mistakes in this document.</p>
				<p>If you'd like to contribute to this document with suggestions or corrections, please contact me using the information in the <a href="#maintainers">최신 개정판 &amp; 작성자</a> section.</p>
				<p class="back"><a href="#">위로 이동</a></p>
			</section>
		</article>
	</main>
	<footer>
		<a rel="bookmark" href="/">PHP Best Practices</a> by <a rel="author" href="https://alexcabal.com">Alex Cabal</a> is released into the <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">public domain</a>. <a href="https://alexcabal.com/why-i-release-things-into-the-public-domain">Why?</a>
	</footer>
</body>

</html>
